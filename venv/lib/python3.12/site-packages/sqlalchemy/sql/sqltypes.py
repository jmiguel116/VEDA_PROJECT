# sql/sqltypes.py
<<<<<<< HEAD
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php
=======
# Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
# mypy: allow-untyped-defs, allow-untyped-calls
>>>>>>> 516a66495 (Reinitialize repository and add files)

"""SQL specific types.

"""
<<<<<<< HEAD

import codecs
import datetime as dt
import decimal
import json

from . import elements
from . import operators
from . import type_api
from .base import _bind_or_error
from .base import NO_ARG
from .base import SchemaEventTarget
from .elements import _literal_as_binds
from .elements import _NONE_NAME
=======
from __future__ import annotations

import collections.abc as collections_abc
import datetime as dt
import decimal
import enum
import json
import pickle
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from uuid import UUID as _python_UUID

from . import coercions
from . import elements
from . import operators
from . import roles
from . import type_api
from .base import _NONE_NAME
from .base import NO_ARG
from .base import SchemaEventTarget
from .cache_key import HasCacheKey
>>>>>>> 516a66495 (Reinitialize repository and add files)
from .elements import quoted_name
from .elements import Slice
from .elements import TypeCoerce as type_coerce  # noqa
from .type_api import Emulated
from .type_api import NativeForEmulated  # noqa
<<<<<<< HEAD
from .type_api import to_instance
from .type_api import TypeDecorator
from .type_api import TypeEngine
from .type_api import Variant
from .. import event
from .. import exc
from .. import inspection
from .. import processors
from .. import util
from ..util import compat
from ..util import langhelpers
from ..util import pickle


if util.jython:
    import array


class _LookupExpressionAdapter(object):

=======
from .type_api import to_instance as to_instance
from .type_api import TypeDecorator as TypeDecorator
from .type_api import TypeEngine as TypeEngine
from .type_api import TypeEngineMixin
from .type_api import Variant  # noqa
from .visitors import InternalTraversal
from .. import event
from .. import exc
from .. import inspection
from .. import util
from ..engine import processors
from ..util import langhelpers
from ..util import OrderedDict
from ..util.typing import is_literal
from ..util.typing import Literal
from ..util.typing import typing_get_args

if TYPE_CHECKING:
    from ._typing import _ColumnExpressionArgument
    from ._typing import _TypeEngineArgument
    from .operators import OperatorType
    from .schema import MetaData
    from .type_api import _BindProcessorType
    from .type_api import _ComparatorFactory
    from .type_api import _MatchedOnType
    from .type_api import _ResultProcessorType
    from ..engine.interfaces import Dialect

_T = TypeVar("_T", bound="Any")
_CT = TypeVar("_CT", bound=Any)
_TE = TypeVar("_TE", bound="TypeEngine[Any]")


class HasExpressionLookup(TypeEngineMixin):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """Mixin expression adaptations based on lookup tables.

    These rules are currently used by the numeric, integer and date types
    which have detailed cross-expression coercion rules.

    """

    @property
    def _expression_adaptations(self):
        raise NotImplementedError()

<<<<<<< HEAD
    class Comparator(TypeEngine.Comparator):
        _blank_dict = util.immutabledict()

        def _adapt_expression(self, op, other_comparator):
            othertype = other_comparator.type._type_affinity
=======
    class Comparator(TypeEngine.Comparator[_CT]):
        __slots__ = ()

        _blank_dict = util.EMPTY_DICT

        def _adapt_expression(
            self,
            op: OperatorType,
            other_comparator: TypeEngine.Comparator[Any],
        ) -> Tuple[OperatorType, TypeEngine[Any]]:
            othertype = other_comparator.type._type_affinity
            if TYPE_CHECKING:
                assert isinstance(self.type, HasExpressionLookup)
>>>>>>> 516a66495 (Reinitialize repository and add files)
            lookup = self.type._expression_adaptations.get(
                op, self._blank_dict
            ).get(othertype, self.type)
            if lookup is othertype:
                return (op, other_comparator.type)
            elif lookup is self.type._type_affinity:
                return (op, self.type)
            else:
                return (op, to_instance(lookup))

<<<<<<< HEAD
    comparator_factory = Comparator


class Concatenable(object):

    """A mixin that marks a type as supporting 'concatenation',
    typically strings."""

    class Comparator(TypeEngine.Comparator):
        def _adapt_expression(self, op, other_comparator):
=======
    comparator_factory: _ComparatorFactory[Any] = Comparator


class Concatenable(TypeEngineMixin):
    """A mixin that marks a type as supporting 'concatenation',
    typically strings."""

    class Comparator(TypeEngine.Comparator[_T]):
        __slots__ = ()

        def _adapt_expression(
            self,
            op: OperatorType,
            other_comparator: TypeEngine.Comparator[Any],
        ) -> Tuple[OperatorType, TypeEngine[Any]]:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            if op is operators.add and isinstance(
                other_comparator,
                (Concatenable.Comparator, NullType.Comparator),
            ):
                return operators.concat_op, self.expr.type
            else:
<<<<<<< HEAD
                return super(Concatenable.Comparator, self)._adapt_expression(
                    op, other_comparator
                )

    comparator_factory = Comparator


class Indexable(object):
    """A mixin that marks a type as supporting indexing operations,
    such as array or JSON structures.


    .. versionadded:: 1.1.0


    """

    class Comparator(TypeEngine.Comparator):
=======
                return super()._adapt_expression(op, other_comparator)

    comparator_factory: _ComparatorFactory[Any] = Comparator


class Indexable(TypeEngineMixin):
    """A mixin that marks a type as supporting indexing operations,
    such as array or JSON structures.

    """

    class Comparator(TypeEngine.Comparator[_T]):
        __slots__ = ()

>>>>>>> 516a66495 (Reinitialize repository and add files)
        def _setup_getitem(self, index):
            raise NotImplementedError()

        def __getitem__(self, index):
            (
                adjusted_op,
                adjusted_right_expr,
                result_type,
            ) = self._setup_getitem(index)
            return self.operate(
                adjusted_op, adjusted_right_expr, result_type=result_type
            )

<<<<<<< HEAD
    comparator_factory = Comparator


class String(Concatenable, TypeEngine):

    """The base for all string and character types.

    In SQL, corresponds to VARCHAR.  Can also take Python unicode objects
    and encode to the database's encoding in bind params (and the reverse for
    result sets.)
=======
    comparator_factory: _ComparatorFactory[Any] = Comparator


class String(Concatenable, TypeEngine[str]):
    """The base for all string and character types.

    In SQL, corresponds to VARCHAR.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    The `length` field is usually required when the `String` type is
    used within a CREATE TABLE statement, as VARCHAR requires a length
    on most databases.

    """

    __visit_name__ = "string"

<<<<<<< HEAD
    @util.deprecated_params(
        convert_unicode=(
            "1.3",
            "The :paramref:`.String.convert_unicode` parameter is deprecated "
            "and will be removed in a future release.  All modern DBAPIs "
            "now support Python Unicode directly and this parameter is "
            "unnecessary.",
        ),
        unicode_error=(
            "1.3",
            "The :paramref:`.String.unicode_errors` parameter is deprecated "
            "and will be removed in a future release.  This parameter is "
            "unnecessary for modern Python DBAPIs and degrades performance "
            "significantly.",
        ),
    )
    def __init__(
        self,
        length=None,
        collation=None,
        convert_unicode=False,
        unicode_error=None,
        _warn_on_bytestring=False,
        _expect_unicode=False,
=======
    def __init__(
        self,
        length: Optional[int] = None,
        collation: Optional[str] = None,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        """
        Create a string-holding type.

        :param length: optional, a length for the column for use in
          DDL and CAST expressions.  May be safely omitted if no ``CREATE
          TABLE`` will be issued.  Certain databases may require a
          ``length`` for use in DDL, and will raise an exception when
          the ``CREATE TABLE`` DDL is issued if a ``VARCHAR``
          with no length is included.  Whether the value is
          interpreted as bytes or characters is database specific.

        :param collation: Optional, a column-level collation for
          use in DDL and CAST expressions.  Renders using the
          COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
<<<<<<< HEAD
          E.g.::

            >>> from sqlalchemy import cast, select, String
            >>> print(select([cast('some string', String(collation='utf8'))]))
            SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1

        :param convert_unicode: When set to ``True``, the
          :class:`.String` type will assume that
          input is to be passed as Python Unicode objects under Python 2,
          and results returned as Python Unicode objects.
          In the rare circumstance that the DBAPI does not support
          Python unicode under Python 2, SQLAlchemy will use its own
          encoder/decoder functionality on strings, referring to the
          value of the :paramref:`_sa.create_engine.encoding` parameter
          parameter passed to :func:`_sa.create_engine` as the encoding.

          For the extremely rare case that Python Unicode
          is to be encoded/decoded by SQLAlchemy on a backend
          that *does* natively support Python Unicode,
          the string value ``"force"`` can be passed here which will
          cause SQLAlchemy's encode/decode services to be
          used unconditionally.

          .. note::

            SQLAlchemy's unicode-conversion flags and features only apply
            to Python 2; in Python 3, all string objects are Unicode objects.
            For this reason, as well as the fact that virtually all modern
            DBAPIs now support Unicode natively even under Python 2,
            the :paramref:`.String.convert_unicode` flag is inherently a
            legacy feature.

          .. note::

            In the vast majority of cases, the :class:`.Unicode` or
            :class:`.UnicodeText` datatypes should be used for a
            :class:`_schema.Column` that expects to store non-ascii data.
            These
            datatypes will ensure that the correct types are used on the
            database side as well as set up the correct Unicode behaviors
            under Python 2.

          .. seealso::

            :paramref:`_sa.create_engine.convert_unicode` -
            :class:`_engine.Engine`-wide parameter

        :param unicode_error: Optional, a method to use to handle Unicode
          conversion errors. Behaves like the ``errors`` keyword argument to
          the standard library's ``string.decode()`` functions, requires
          that :paramref:`.String.convert_unicode` is set to
          ``"force"``

        """
        if unicode_error is not None and convert_unicode != "force":
            raise exc.ArgumentError(
                "convert_unicode must be 'force' " "when unicode_error is set."
            )

        self.length = length
        self.collation = collation
        self._expect_unicode = convert_unicode or _expect_unicode
        self._expect_unicode_error = unicode_error

        self._warn_on_bytestring = _warn_on_bytestring
=======
          E.g.:

          .. sourcecode:: pycon+sql

            >>> from sqlalchemy import cast, select, String
            >>> print(select(cast('some string', String(collation='utf8'))))
            {printsql}SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1

          .. note::

            In most cases, the :class:`.Unicode` or :class:`.UnicodeText`
            datatypes should be used for a :class:`_schema.Column` that expects
            to store non-ascii data. These datatypes will ensure that the
            correct types are used on the database.

        """

        self.length = length
        self.collation = collation

    def _resolve_for_literal(self, value):
        # I was SO PROUD of my regex trick, but we dont need it.
        # re.search(r"[^\u0000-\u007F]", value)

        if value.isascii():
            return _STRING
        else:
            return _UNICODE
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def literal_processor(self, dialect):
        def process(value):
            value = value.replace("'", "''")

            if dialect.identifier_preparer._double_percents:
                value = value.replace("%", "%%")

            return "'%s'" % value

        return process

    def bind_processor(self, dialect):
<<<<<<< HEAD
        if self._expect_unicode or dialect.convert_unicode:
            if (
                dialect.supports_unicode_binds
                and self._expect_unicode != "force"
            ):
                if self._warn_on_bytestring:

                    def process(value):
                        if isinstance(value, util.binary_type):
                            util.warn_limited(
                                "Unicode type received non-unicode "
                                "bind param value %r.",
                                (util.ellipses_string(value),),
                            )
                        return value

                    return process
                else:
                    return None
            else:
                encoder = codecs.getencoder(dialect.encoding)
                warn_on_bytestring = self._warn_on_bytestring

                def process(value):
                    if isinstance(value, util.text_type):
                        return encoder(value, self._expect_unicode_error)[0]
                    elif warn_on_bytestring and value is not None:
                        util.warn_limited(
                            "Unicode type received non-unicode bind "
                            "param value %r.",
                            (util.ellipses_string(value),),
                        )
                    return value

            return process
        else:
            return None

    def result_processor(self, dialect, coltype):
        wants_unicode = self._expect_unicode or dialect.convert_unicode
        needs_convert = wants_unicode and (
            dialect.returns_unicode_strings is not True
            or self._expect_unicode in ("force", "force_nocheck")
        )
        needs_isinstance = (
            needs_convert
            and dialect.returns_unicode_strings
            and self._expect_unicode != "force_nocheck"
        )
        if needs_convert:
            if needs_isinstance:
                return processors.to_conditional_unicode_processor_factory(
                    dialect.encoding, self._expect_unicode_error
                )
            else:
                return processors.to_unicode_processor_factory(
                    dialect.encoding, self._expect_unicode_error
                )
        else:
            return None

    @property
    def python_type(self):
        if self._expect_unicode:
            return util.text_type
        else:
            return str
=======
        return None

    def result_processor(self, dialect, coltype):
        return None

    @property
    def python_type(self):
        return str
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def get_dbapi_type(self, dbapi):
        return dbapi.STRING

<<<<<<< HEAD
    @classmethod
    def _warn_deprecated_unicode(cls):
        util.warn_deprecated(
            "The convert_unicode on Engine and String as well as the "
            "unicode_error flag on String are deprecated.  All modern "
            "DBAPIs now support Python Unicode natively under Python 2, and "
            "under Python 3 all strings are inherently Unicode.  These flags "
            "will be removed in a future release."
        )


class Text(String):

    """A variably sized string type.

    In SQL, usually corresponds to CLOB or TEXT. Can also take Python
    unicode objects and encode to the database's encoding in bind
    params (and the reverse for result sets.)  In general, TEXT objects
=======

class Text(String):
    """A variably sized string type.

    In SQL, usually corresponds to CLOB or TEXT.  In general, TEXT objects
>>>>>>> 516a66495 (Reinitialize repository and add files)
    do not have a length; while some databases will accept a length
    argument here, it will be rejected by others.

    """

    __visit_name__ = "text"


class Unicode(String):
<<<<<<< HEAD

    """A variable length Unicode string type.

    The :class:`.Unicode` type is a :class:`.String` subclass
    that assumes input and output as Python ``unicode`` data,
    and in that regard is equivalent to the usage of the
    ``convert_unicode`` flag with the :class:`.String` type.
    However, unlike plain :class:`.String`, it also implies an
    underlying column type that is explicitly supporting of non-ASCII
    data, such as ``NVARCHAR`` on Oracle and SQL Server.
    This can impact the output of ``CREATE TABLE`` statements
    and ``CAST`` functions at the dialect level, and can
    also affect the handling of bound parameters in some
    specific DBAPI scenarios.

    The encoding used by the :class:`.Unicode` type is usually
    determined by the DBAPI itself; most modern DBAPIs
    feature support for Python ``unicode`` objects as bound
    values and result set values, and the encoding should
    be configured as detailed in the notes for the target
    DBAPI in the :ref:`dialect_toplevel` section.

    For those DBAPIs which do not support, or are not configured
    to accommodate Python ``unicode`` objects
    directly, SQLAlchemy does the encoding and decoding
    outside of the DBAPI.   The encoding in this scenario
    is determined by the ``encoding`` flag passed to
    :func:`_sa.create_engine`.

    When using the :class:`.Unicode` type, it is only appropriate
    to pass Python ``unicode`` objects, and not plain ``str``.
    If a plain ``str`` is passed under Python 2, a warning
    is emitted.  If you notice your application emitting these warnings but
    you're not sure of the source of them, the Python
    ``warnings`` filter, documented at
    http://docs.python.org/library/warnings.html,
    can be used to turn these warnings into exceptions
    which will illustrate a stack trace::

      import warnings
      warnings.simplefilter('error')

    For an application that wishes to pass plain bytestrings
    and Python ``unicode`` objects to the ``Unicode`` type
    equally, the bytestrings must first be decoded into
    unicode.  The recipe at :ref:`coerce_to_unicode` illustrates
    how this is done.
=======
    """A variable length Unicode string type.

    The :class:`.Unicode` type is a :class:`.String` subclass that assumes
    input and output strings that may contain non-ASCII characters, and for
    some backends implies an underlying column type that is explicitly
    supporting of non-ASCII data, such as ``NVARCHAR`` on Oracle and SQL
    Server.  This will impact the output of ``CREATE TABLE`` statements and
    ``CAST`` functions at the dialect level.

    The character encoding used by the :class:`.Unicode` type that is used to
    transmit and receive data to the database is usually determined by the
    DBAPI itself. All modern DBAPIs accommodate non-ASCII strings but may have
    different methods of managing database encodings; if necessary, this
    encoding should be configured as detailed in the notes for the target DBAPI
    in the :ref:`dialect_toplevel` section.

    In modern SQLAlchemy, use of the :class:`.Unicode` datatype does not
    imply any encoding/decoding behavior within SQLAlchemy itself.  In Python
    3, all string objects are inherently Unicode capable, and SQLAlchemy
    does not produce bytestring objects nor does it accommodate a DBAPI that
    does not return Python Unicode objects in result sets for string values.

    .. warning:: Some database backends, particularly SQL Server with pyodbc,
       are known to have undesirable behaviors regarding data that is noted
       as being of ``NVARCHAR`` type as opposed to ``VARCHAR``, including
       datatype mismatch errors and non-use of indexes.  See the section
       on :meth:`.DialectEvents.do_setinputsizes` for background on working
       around unicode character issues for backends like SQL Server with
       pyodbc as well as cx_Oracle.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    .. seealso::

        :class:`.UnicodeText` - unlengthed textual counterpart
        to :class:`.Unicode`.

<<<<<<< HEAD
=======
        :meth:`.DialectEvents.do_setinputsizes`


>>>>>>> 516a66495 (Reinitialize repository and add files)
    """

    __visit_name__ = "unicode"

<<<<<<< HEAD
    def __init__(self, length=None, **kwargs):
        """
        Create a :class:`.Unicode` object.

        Parameters are the same as that of :class:`.String`,
        with the exception that ``convert_unicode``
        defaults to ``True``.

        """
        kwargs.setdefault("_expect_unicode", True)
        kwargs.setdefault("_warn_on_bytestring", True)
        super(Unicode, self).__init__(length=length, **kwargs)


class UnicodeText(Text):

=======

class UnicodeText(Text):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """An unbounded-length Unicode string type.

    See :class:`.Unicode` for details on the unicode
    behavior of this object.

    Like :class:`.Unicode`, usage the :class:`.UnicodeText` type implies a
    unicode-capable type being used on the backend, such as
    ``NCLOB``, ``NTEXT``.

    """

    __visit_name__ = "unicode_text"

<<<<<<< HEAD
    def __init__(self, length=None, **kwargs):
        """
        Create a Unicode-converting Text type.

        Parameters are the same as that of :class:`_expression.TextClause`,
        with the exception that ``convert_unicode``
        defaults to ``True``.

        """
        kwargs.setdefault("_expect_unicode", True)
        kwargs.setdefault("_warn_on_bytestring", True)
        super(UnicodeText, self).__init__(length=length, **kwargs)

    def _warn_deprecated_unicode(self):
        pass


class Integer(_LookupExpressionAdapter, TypeEngine):

=======

class Integer(HasExpressionLookup, TypeEngine[int]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for ``int`` integers."""

    __visit_name__ = "integer"

<<<<<<< HEAD
=======
    if TYPE_CHECKING:

        @util.ro_memoized_property
        def _type_affinity(self) -> Type[Integer]: ...

>>>>>>> 516a66495 (Reinitialize repository and add files)
    def get_dbapi_type(self, dbapi):
        return dbapi.NUMBER

    @property
    def python_type(self):
        return int

<<<<<<< HEAD
    def literal_processor(self, dialect):
        def process(value):
            return str(value)
=======
    def _resolve_for_literal(self, value):
        if value.bit_length() >= 32:
            return _BIGINTEGER
        else:
            return self

    def literal_processor(self, dialect):
        def process(value):
            return str(int(value))
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return process

    @util.memoized_property
    def _expression_adaptations(self):
<<<<<<< HEAD
        # TODO: need a dictionary object that will
        # handle operators generically here, this is incomplete
=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
        return {
            operators.add: {
                Date: Date,
                Integer: self.__class__,
                Numeric: Numeric,
            },
            operators.mul: {
                Interval: Interval,
                Integer: self.__class__,
                Numeric: Numeric,
            },
<<<<<<< HEAD
            operators.div: {Integer: self.__class__, Numeric: Numeric},
            operators.truediv: {Integer: self.__class__, Numeric: Numeric},
=======
            operators.truediv: {Integer: Numeric, Numeric: Numeric},
            operators.floordiv: {Integer: self.__class__, Numeric: Numeric},
>>>>>>> 516a66495 (Reinitialize repository and add files)
            operators.sub: {Integer: self.__class__, Numeric: Numeric},
        }


class SmallInteger(Integer):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for smaller ``int`` integers.

    Typically generates a ``SMALLINT`` in DDL, and otherwise acts like
    a normal :class:`.Integer` on the Python side.

    """

    __visit_name__ = "small_integer"


class BigInteger(Integer):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for bigger ``int`` integers.

    Typically generates a ``BIGINT`` in DDL, and otherwise acts like
    a normal :class:`.Integer` on the Python side.

    """

    __visit_name__ = "big_integer"


<<<<<<< HEAD
class Numeric(_LookupExpressionAdapter, TypeEngine):

    """A type for fixed precision numbers, such as ``NUMERIC`` or ``DECIMAL``.

    This type returns Python ``decimal.Decimal`` objects by default, unless
    the :paramref:`.Numeric.asdecimal` flag is set to False, in which case
    they are coerced to Python ``float`` objects.

    .. note::

        The :class:`.Numeric` type is designed to receive data from a database
        type that is explicitly known to be a decimal type
        (e.g. ``DECIMAL``, ``NUMERIC``, others) and not a floating point
        type (e.g. ``FLOAT``, ``REAL``, others).
        If the database column on the server is in fact a floating-point
        type, such as ``FLOAT`` or ``REAL``, use the :class:`.Float`
        type or a subclass, otherwise numeric coercion between
        ``float``/``Decimal`` may or may not function as expected.

    .. note::

       The Python ``decimal.Decimal`` class is generally slow
       performing; cPython 3.3 has now switched to use the `cdecimal
       <http://pypi.python.org/pypi/cdecimal/>`_ library natively. For
       older Python versions, the ``cdecimal`` library can be patched
       into any application where it will replace the ``decimal``
       library fully, however this needs to be applied globally and
       before any other modules have been imported, as follows::

           import sys
           import cdecimal
           sys.modules["decimal"] = cdecimal

       Note that the ``cdecimal`` and ``decimal`` libraries are **not
       compatible with each other**, so patching ``cdecimal`` at the
       global level is the only way it can be used effectively with
       various DBAPIs that hardcode to import the ``decimal`` library.
=======
_N = TypeVar("_N", bound=Union[decimal.Decimal, float])


class Numeric(HasExpressionLookup, TypeEngine[_N]):
    """Base for non-integer numeric types, such as
    ``NUMERIC``, ``FLOAT``, ``DECIMAL``, and other variants.

    The :class:`.Numeric` datatype when used directly will render DDL
    corresponding to precision numerics if available, such as
    ``NUMERIC(precision, scale)``.  The :class:`.Float` subclass will
    attempt to render a floating-point datatype such as ``FLOAT(precision)``.

    :class:`.Numeric` returns Python ``decimal.Decimal`` objects by default,
    based on the default value of ``True`` for the
    :paramref:`.Numeric.asdecimal` parameter.  If this parameter is set to
    False, returned values are coerced to Python ``float`` objects.

    The :class:`.Float` subtype, being more specific to floating point,
    defaults the :paramref:`.Float.asdecimal` flag to False so that the
    default Python datatype is ``float``.

    .. note::

        When using a :class:`.Numeric` datatype against a database type that
        returns Python floating point values to the driver, the accuracy of the
        decimal conversion indicated by :paramref:`.Numeric.asdecimal` may be
        limited.   The behavior of specific numeric/floating point datatypes
        is a product of the SQL datatype in use, the Python :term:`DBAPI`
        in use, as well as strategies that may be present within
        the SQLAlchemy dialect in use.   Users requiring specific precision/
        scale are encouraged to experiment with the available datatypes
        in order to determine the best results.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    """

    __visit_name__ = "numeric"

<<<<<<< HEAD
    _default_decimal_return_scale = 10

    def __init__(
        self,
        precision=None,
        scale=None,
        decimal_return_scale=None,
        asdecimal=True,
=======
    if TYPE_CHECKING:

        @util.ro_memoized_property
        def _type_affinity(self) -> Type[Numeric[_N]]: ...

    _default_decimal_return_scale = 10

    @overload
    def __init__(
        self: Numeric[decimal.Decimal],
        precision: Optional[int] = ...,
        scale: Optional[int] = ...,
        decimal_return_scale: Optional[int] = ...,
        asdecimal: Literal[True] = ...,
    ): ...

    @overload
    def __init__(
        self: Numeric[float],
        precision: Optional[int] = ...,
        scale: Optional[int] = ...,
        decimal_return_scale: Optional[int] = ...,
        asdecimal: Literal[False] = ...,
    ): ...

    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        decimal_return_scale: Optional[int] = None,
        asdecimal: bool = True,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        """
        Construct a Numeric.

        :param precision: the numeric precision for use in DDL ``CREATE
          TABLE``.

        :param scale: the numeric scale for use in DDL ``CREATE TABLE``.

        :param asdecimal: default True.  Return whether or not
          values should be sent as Python Decimal objects, or
          as floats.   Different DBAPIs send one or the other based on
          datatypes - the Numeric type will ensure that return values
          are one or the other across DBAPIs consistently.

        :param decimal_return_scale: Default scale to use when converting
         from floats to Python decimals.  Floating point values will typically
         be much longer due to decimal inaccuracy, and most floating point
         database types don't have a notion of "scale", so by default the
         float type looks for the first ten decimal places when converting.
         Specifying this value will override that length.  Types which
         do include an explicit ".scale" value, such as the base
         :class:`.Numeric` as well as the MySQL float types, will use the
         value of ".scale" as the default for decimal_return_scale, if not
         otherwise specified.

<<<<<<< HEAD
         .. versionadded:: 0.9.0

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
        When using the ``Numeric`` type, care should be taken to ensure
        that the asdecimal setting is appropriate for the DBAPI in use -
        when Numeric applies a conversion from Decimal->float or float->
        Decimal, this conversion incurs an additional performance overhead
        for all result columns received.

        DBAPIs that return Decimal natively (e.g. psycopg2) will have
        better accuracy and higher performance with a setting of ``True``,
        as the native translation to Decimal reduces the amount of floating-
        point issues at play, and the Numeric type itself doesn't need
        to apply any further conversions.  However, another DBAPI which
        returns floats natively *will* incur an additional conversion
        overhead, and is still subject to floating point data loss - in
        which case ``asdecimal=False`` will at least remove the extra
        conversion overhead.

        """
        self.precision = precision
        self.scale = scale
        self.decimal_return_scale = decimal_return_scale
        self.asdecimal = asdecimal

    @property
    def _effective_decimal_return_scale(self):
        if self.decimal_return_scale is not None:
            return self.decimal_return_scale
        elif getattr(self, "scale", None) is not None:
            return self.scale
        else:
            return self._default_decimal_return_scale

    def get_dbapi_type(self, dbapi):
        return dbapi.NUMBER

    def literal_processor(self, dialect):
        def process(value):
            return str(value)

        return process

    @property
    def python_type(self):
        if self.asdecimal:
            return decimal.Decimal
        else:
            return float

    def bind_processor(self, dialect):
        if dialect.supports_native_decimal:
            return None
        else:
            return processors.to_float

    def result_processor(self, dialect, coltype):
        if self.asdecimal:
            if dialect.supports_native_decimal:
                # we're a "numeric", DBAPI will give us Decimal directly
                return None
            else:
<<<<<<< HEAD
                util.warn(
                    "Dialect %s+%s does *not* support Decimal "
                    "objects natively, and SQLAlchemy must "
                    "convert from floating point - rounding "
                    "errors and other issues may occur. Please "
                    "consider storing Decimal numbers as strings "
                    "or integers on this platform for lossless "
                    "storage." % (dialect.name, dialect.driver)
                )

                # we're a "numeric", DBAPI returns floats, convert.
                return processors.to_decimal_processor_factory(
                    decimal.Decimal,
                    self.scale
                    if self.scale is not None
                    else self._default_decimal_return_scale,
=======
                # we're a "numeric", DBAPI returns floats, convert.
                return processors.to_decimal_processor_factory(
                    decimal.Decimal,
                    (
                        self.scale
                        if self.scale is not None
                        else self._default_decimal_return_scale
                    ),
>>>>>>> 516a66495 (Reinitialize repository and add files)
                )
        else:
            if dialect.supports_native_decimal:
                return processors.to_float
            else:
                return None

    @util.memoized_property
    def _expression_adaptations(self):
        return {
            operators.mul: {
                Interval: Interval,
                Numeric: self.__class__,
                Integer: self.__class__,
            },
<<<<<<< HEAD
            operators.div: {Numeric: self.__class__, Integer: self.__class__},
=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
            operators.truediv: {
                Numeric: self.__class__,
                Integer: self.__class__,
            },
            operators.add: {Numeric: self.__class__, Integer: self.__class__},
            operators.sub: {Numeric: self.__class__, Integer: self.__class__},
        }


<<<<<<< HEAD
class Float(Numeric):

    """Type representing floating point types, such as ``FLOAT`` or ``REAL``.

    This type returns Python ``float`` objects by default, unless the
    :paramref:`.Float.asdecimal` flag is set to True, in which case they
    are coerced to ``decimal.Decimal`` objects.

    .. note::

        The :class:`.Float` type is designed to receive data from a database
        type that is explicitly known to be a floating point type
        (e.g. ``FLOAT``, ``REAL``, others)
        and not a decimal type (e.g. ``DECIMAL``, ``NUMERIC``, others).
        If the database column on the server is in fact a Numeric
        type, such as ``DECIMAL`` or ``NUMERIC``, use the :class:`.Numeric`
        type or a subclass, otherwise numeric coercion between
        ``float``/``Decimal`` may or may not function as expected.

=======
class Float(Numeric[_N]):
    """Type representing floating point types, such as ``FLOAT`` or ``REAL``.

    This type returns Python ``float`` objects by default, unless the
    :paramref:`.Float.asdecimal` flag is set to ``True``, in which case they
    are coerced to ``decimal.Decimal`` objects.

    When a :paramref:`.Float.precision` is not provided in a
    :class:`_types.Float` type some backend may compile this type as
    an 8 bytes / 64 bit float datatype. To use a 4 bytes / 32 bit float
    datatype a precision <= 24 can usually be provided or the
    :class:`_types.REAL` type can be used.
    This is known to be the case in the PostgreSQL and MSSQL dialects
    that render the type as ``FLOAT`` that's in both an alias of
    ``DOUBLE PRECISION``. Other third party dialects may have similar
    behavior.
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """

    __visit_name__ = "float"

    scale = None

<<<<<<< HEAD
    def __init__(
        self, precision=None, asdecimal=False, decimal_return_scale=None
=======
    @overload
    def __init__(
        self: Float[float],
        precision: Optional[int] = ...,
        asdecimal: Literal[False] = ...,
        decimal_return_scale: Optional[int] = ...,
    ): ...

    @overload
    def __init__(
        self: Float[decimal.Decimal],
        precision: Optional[int] = ...,
        asdecimal: Literal[True] = ...,
        decimal_return_scale: Optional[int] = ...,
    ): ...

    def __init__(
        self: Float[_N],
        precision: Optional[int] = None,
        asdecimal: bool = False,
        decimal_return_scale: Optional[int] = None,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        r"""
        Construct a Float.

        :param precision: the numeric precision for use in DDL ``CREATE
<<<<<<< HEAD
           TABLE``.
=======
           TABLE``. Backends **should** attempt to ensure this precision
           indicates a number of digits for the generic
           :class:`_sqltypes.Float` datatype.

           .. note:: For the Oracle backend, the
              :paramref:`_sqltypes.Float.precision` parameter is not accepted
              when rendering DDL, as Oracle does not support float precision
              specified as a number of decimal places. Instead, use the
              Oracle-specific :class:`_oracle.FLOAT` datatype and specify the
              :paramref:`_oracle.FLOAT.binary_precision` parameter. This is new
              in version 2.0 of SQLAlchemy.

              To create a database agnostic :class:`_types.Float` that
              separately specifies binary precision for Oracle, use
              :meth:`_types.TypeEngine.with_variant` as follows::

                    from sqlalchemy import Column
                    from sqlalchemy import Float
                    from sqlalchemy.dialects import oracle

                    Column(
                        "float_data",
                        Float(5).with_variant(oracle.FLOAT(binary_precision=16), "oracle")
                    )
>>>>>>> 516a66495 (Reinitialize repository and add files)

        :param asdecimal: the same flag as that of :class:`.Numeric`, but
          defaults to ``False``.   Note that setting this flag to ``True``
          results in floating point conversion.

        :param decimal_return_scale: Default scale to use when converting
         from floats to Python decimals.  Floating point values will typically
         be much longer due to decimal inaccuracy, and most floating point
         database types don't have a notion of "scale", so by default the
         float type looks for the first ten decimal places when converting.
         Specifying this value will override that length.  Note that the
         MySQL float types, which do include "scale", will use "scale"
         as the default for decimal_return_scale, if not otherwise specified.

<<<<<<< HEAD
         .. versionadded:: 0.9.0

        """
=======
        """  # noqa: E501
>>>>>>> 516a66495 (Reinitialize repository and add files)
        self.precision = precision
        self.asdecimal = asdecimal
        self.decimal_return_scale = decimal_return_scale

    def result_processor(self, dialect, coltype):
        if self.asdecimal:
            return processors.to_decimal_processor_factory(
                decimal.Decimal, self._effective_decimal_return_scale
            )
        elif dialect.supports_native_decimal:
            return processors.to_float
        else:
            return None


<<<<<<< HEAD
class DateTime(_LookupExpressionAdapter, TypeEngine):

=======
class Double(Float[_N]):
    """A type for double ``FLOAT`` floating point types.

    Typically generates a ``DOUBLE`` or ``DOUBLE_PRECISION`` in DDL,
    and otherwise acts like a normal :class:`.Float` on the Python
    side.

    .. versionadded:: 2.0

    """

    __visit_name__ = "double"


class _RenderISO8601NoT:
    def _literal_processor_datetime(self, dialect):
        return self._literal_processor_portion(dialect, None)

    def _literal_processor_date(self, dialect):
        return self._literal_processor_portion(dialect, 0)

    def _literal_processor_time(self, dialect):
        return self._literal_processor_portion(dialect, -1)

    def _literal_processor_portion(self, dialect, _portion=None):
        assert _portion in (None, 0, -1)
        if _portion is not None:

            def process(value):
                return f"""'{value.isoformat().split("T")[_portion]}'"""

        else:

            def process(value):
                return f"""'{value.isoformat().replace("T", " ")}'"""

        return process


class DateTime(
    _RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.datetime]
):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for ``datetime.datetime()`` objects.

    Date and time types return objects from the Python ``datetime``
    module.  Most DBAPIs have built in support for the datetime
    module, with the noted exception of SQLite.  In the case of
    SQLite, date and time types are stored as strings which are then
    converted back to datetime objects when rows are returned.

    For the time representation within the datetime type, some
    backends include additional options, such as timezone support and
    fractional seconds support.  For fractional seconds, use the
    dialect-specific datatype, such as :class:`.mysql.TIME`.  For
    timezone support, use at least the :class:`_types.TIMESTAMP` datatype,
    if not the dialect-specific datatype object.

    """

    __visit_name__ = "datetime"

<<<<<<< HEAD
    def __init__(self, timezone=False):
=======
    def __init__(self, timezone: bool = False):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Construct a new :class:`.DateTime`.

        :param timezone: boolean.  Indicates that the datetime type should
         enable timezone support, if available on the
         **base date/time-holding type only**.   It is recommended
         to make use of the :class:`_types.TIMESTAMP` datatype directly when
         using this flag, as some databases include separate generic
         date/time-holding types distinct from the timezone-capable
         TIMESTAMP datatype, such as Oracle.


        """
        self.timezone = timezone

    def get_dbapi_type(self, dbapi):
        return dbapi.DATETIME

<<<<<<< HEAD
=======
    def _resolve_for_literal(self, value):
        with_timezone = value.tzinfo is not None
        if with_timezone and not self.timezone:
            return DATETIME_TIMEZONE
        else:
            return self

    def literal_processor(self, dialect):
        return self._literal_processor_datetime(dialect)

>>>>>>> 516a66495 (Reinitialize repository and add files)
    @property
    def python_type(self):
        return dt.datetime

    @util.memoized_property
    def _expression_adaptations(self):
<<<<<<< HEAD

        # Based on http://www.postgresql.org/docs/current/\
        # static/functions-datetime.html.
=======
        # Based on
        # https://www.postgresql.org/docs/current/static/functions-datetime.html.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return {
            operators.add: {Interval: self.__class__},
            operators.sub: {Interval: self.__class__, DateTime: Interval},
        }


<<<<<<< HEAD
class Date(_LookupExpressionAdapter, TypeEngine):

=======
class Date(_RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.date]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for ``datetime.date()`` objects."""

    __visit_name__ = "date"

    def get_dbapi_type(self, dbapi):
        return dbapi.DATETIME

    @property
    def python_type(self):
        return dt.date

<<<<<<< HEAD
    @util.memoized_property
    def _expression_adaptations(self):
        # Based on http://www.postgresql.org/docs/current/\
        # static/functions-datetime.html.
=======
    def literal_processor(self, dialect):
        return self._literal_processor_date(dialect)

    @util.memoized_property
    def _expression_adaptations(self):
        # Based on
        # https://www.postgresql.org/docs/current/static/functions-datetime.html.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return {
            operators.add: {
                Integer: self.__class__,
                Interval: DateTime,
                Time: DateTime,
            },
            operators.sub: {
                # date - integer = date
                Integer: self.__class__,
                # date - date = integer.
                Date: Integer,
                Interval: DateTime,
                # date - datetime = interval,
                # this one is not in the PG docs
                # but works
                DateTime: Interval,
            },
        }


<<<<<<< HEAD
class Time(_LookupExpressionAdapter, TypeEngine):

=======
class Time(_RenderISO8601NoT, HasExpressionLookup, TypeEngine[dt.time]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for ``datetime.time()`` objects."""

    __visit_name__ = "time"

<<<<<<< HEAD
    def __init__(self, timezone=False):
=======
    def __init__(self, timezone: bool = False):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        self.timezone = timezone

    def get_dbapi_type(self, dbapi):
        return dbapi.DATETIME

    @property
    def python_type(self):
        return dt.time

<<<<<<< HEAD
    @util.memoized_property
    def _expression_adaptations(self):
        # Based on http://www.postgresql.org/docs/current/\
        # static/functions-datetime.html.
=======
    def _resolve_for_literal(self, value):
        with_timezone = value.tzinfo is not None
        if with_timezone and not self.timezone:
            return TIME_TIMEZONE
        else:
            return self

    @util.memoized_property
    def _expression_adaptations(self):
        # Based on
        # https://www.postgresql.org/docs/current/static/functions-datetime.html.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return {
            operators.add: {Date: DateTime, Interval: self.__class__},
            operators.sub: {Time: Interval, Interval: self.__class__},
        }

<<<<<<< HEAD

class _Binary(TypeEngine):

    """Define base behavior for binary types."""

    def __init__(self, length=None):
=======
    def literal_processor(self, dialect):
        return self._literal_processor_time(dialect)


class _Binary(TypeEngine[bytes]):
    """Define base behavior for binary types."""

    def __init__(self, length: Optional[int] = None):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        self.length = length

    def literal_processor(self, dialect):
        def process(value):
<<<<<<< HEAD
            value = value.decode(dialect.encoding).replace("'", "''")
=======
            # TODO: this is useless for real world scenarios; implement
            # real binary literals
            value = value.decode(
                dialect._legacy_binary_type_literal_encoding
            ).replace("'", "''")
>>>>>>> 516a66495 (Reinitialize repository and add files)
            return "'%s'" % value

        return process

    @property
    def python_type(self):
<<<<<<< HEAD
        return util.binary_type
=======
        return bytes
>>>>>>> 516a66495 (Reinitialize repository and add files)

    # Python 3 - sqlite3 doesn't need the `Binary` conversion
    # here, though pg8000 does to indicate "bytea"
    def bind_processor(self, dialect):
        if dialect.dbapi is None:
            return None

        DBAPIBinary = dialect.dbapi.Binary

        def process(value):
            if value is not None:
                return DBAPIBinary(value)
            else:
                return None

        return process

    # Python 3 has native bytes() type
    # both sqlite3 and pg8000 seem to return it,
    # psycopg2 as of 2.5 returns 'memoryview'
<<<<<<< HEAD
    if util.py2k:

        def result_processor(self, dialect, coltype):
            if util.jython:

                def process(value):
                    if value is not None:
                        if isinstance(value, array.array):
                            return value.tostring()
                        return str(value)
                    else:
                        return None

            else:
                process = processors.to_str
            return process

    else:

        def result_processor(self, dialect, coltype):
            def process(value):
                if value is not None:
                    value = bytes(value)
                return value

            return process
=======
    def result_processor(self, dialect, coltype):
        if dialect.returns_native_bytes:
            return None

        def process(value):
            if value is not None:
                value = bytes(value)
            return value

        return process
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def coerce_compared_value(self, op, value):
        """See :meth:`.TypeEngine.coerce_compared_value` for a description."""

<<<<<<< HEAD
        if isinstance(value, util.string_types):
            return self
        else:
            return super(_Binary, self).coerce_compared_value(op, value)
=======
        if isinstance(value, str):
            return self
        else:
            return super().coerce_compared_value(op, value)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def get_dbapi_type(self, dbapi):
        return dbapi.BINARY


class LargeBinary(_Binary):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A type for large binary byte data.

    The :class:`.LargeBinary` type corresponds to a large and/or unlengthed
    binary type for the target platform, such as BLOB on MySQL and BYTEA for
    PostgreSQL.  It also handles the necessary conversions for the DBAPI.

    """

    __visit_name__ = "large_binary"

<<<<<<< HEAD
    def __init__(self, length=None):
=======
    def __init__(self, length: Optional[int] = None):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """
        Construct a LargeBinary type.

        :param length: optional, a length for the column for use in
          DDL statements, for those binary types that accept a length,
          such as the MySQL BLOB type.

        """
        _Binary.__init__(self, length=length)


<<<<<<< HEAD
@util.deprecated_cls(
    "0.6",
    "The :class:`.Binary` class is deprecated and will be removed "
    "in a future relase.  Please use :class:`.LargeBinary`.",
)
class Binary(LargeBinary):
    def __init__(self, *arg, **kw):
        LargeBinary.__init__(self, *arg, **kw)


class SchemaType(SchemaEventTarget):

    """Mark a type as possibly requiring schema-level DDL for usage.
=======
class SchemaType(SchemaEventTarget, TypeEngineMixin):
    """Add capabilities to a type which allow for schema-level DDL to be
    associated with a type.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    Supports types that must be explicitly created/dropped (i.e. PG ENUM type)
    as well as types that are complimented by table or schema level
    constraints, triggers, and other rules.

    :class:`.SchemaType` classes can also be targets for the
    :meth:`.DDLEvents.before_parent_attach` and
    :meth:`.DDLEvents.after_parent_attach` events, where the events fire off
    surrounding the association of the type object with a parent
    :class:`_schema.Column`.

    .. seealso::

        :class:`.Enum`

        :class:`.Boolean`


    """

<<<<<<< HEAD
    def __init__(
        self,
        name=None,
        schema=None,
        metadata=None,
        inherit_schema=False,
        quote=None,
        _create_events=True,
=======
    _use_schema_map = True

    name: Optional[str]

    def __init__(
        self,
        name: Optional[str] = None,
        schema: Optional[str] = None,
        metadata: Optional[MetaData] = None,
        inherit_schema: bool = False,
        quote: Optional[bool] = None,
        _create_events: bool = True,
        _adapted_from: Optional[SchemaType] = None,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        if name is not None:
            self.name = quoted_name(name, quote)
        else:
            self.name = None
        self.schema = schema
        self.metadata = metadata
        self.inherit_schema = inherit_schema
        self._create_events = _create_events

        if _create_events and self.metadata:
            event.listen(
                self.metadata,
                "before_create",
                util.portable_instancemethod(self._on_metadata_create),
            )
            event.listen(
                self.metadata,
                "after_drop",
                util.portable_instancemethod(self._on_metadata_drop),
            )

<<<<<<< HEAD
    def _translate_schema(self, effective_schema, map_):
        return map_.get(effective_schema, effective_schema)

    def _set_parent(self, column, **kw):
        column._on_table_attach(util.portable_instancemethod(self._set_table))

    def _variant_mapping_for_set_table(self, column):
        if isinstance(column.type, Variant):
            variant_mapping = column.type.mapping.copy()
            variant_mapping["_default"] = column.type.impl
=======
        if _adapted_from:
            self.dispatch = self.dispatch._join(_adapted_from.dispatch)

    def _set_parent(self, column, **kw):
        # set parent hook is when this type is associated with a column.
        # Column calls it for all SchemaEventTarget instances, either the
        # base type and/or variants in _variant_mapping.

        # we want to register a second hook to trigger when that column is
        # associated with a table.  in that event, we and all of our variants
        # may want to set up some state on the table such as a CheckConstraint
        # that will conditionally render at DDL render time.

        # the base SchemaType also sets up events for
        # on_table/metadata_create/drop in this method, which is used by
        # "native" types with a separate CREATE/DROP e.g. Postgresql.ENUM

        column._on_table_attach(util.portable_instancemethod(self._set_table))

    def _variant_mapping_for_set_table(self, column):
        if column.type._variant_mapping:
            variant_mapping = dict(column.type._variant_mapping)
            variant_mapping["_default"] = column.type
>>>>>>> 516a66495 (Reinitialize repository and add files)
        else:
            variant_mapping = None
        return variant_mapping

    def _set_table(self, column, table):
        if self.inherit_schema:
            self.schema = table.schema
<<<<<<< HEAD
=======
        elif self.metadata and self.schema is None and self.metadata.schema:
            self.schema = self.metadata.schema
>>>>>>> 516a66495 (Reinitialize repository and add files)

        if not self._create_events:
            return

        variant_mapping = self._variant_mapping_for_set_table(column)

        event.listen(
            table,
            "before_create",
            util.portable_instancemethod(
                self._on_table_create, {"variant_mapping": variant_mapping}
            ),
        )
        event.listen(
            table,
            "after_drop",
            util.portable_instancemethod(
                self._on_table_drop, {"variant_mapping": variant_mapping}
            ),
        )
        if self.metadata is None:
<<<<<<< HEAD
            # TODO: what's the difference between self.metadata
            # and table.metadata here ?
=======
            # if SchemaType were created w/ a metadata argument, these
            # events would already have been associated with that metadata
            # and would preclude an association with table.metadata
>>>>>>> 516a66495 (Reinitialize repository and add files)
            event.listen(
                table.metadata,
                "before_create",
                util.portable_instancemethod(
                    self._on_metadata_create,
                    {"variant_mapping": variant_mapping},
                ),
            )
            event.listen(
                table.metadata,
                "after_drop",
                util.portable_instancemethod(
                    self._on_metadata_drop,
                    {"variant_mapping": variant_mapping},
                ),
            )

    def copy(self, **kw):
<<<<<<< HEAD
        return self.adapt(self.__class__, _create_events=True)

    def adapt(self, impltype, **kw):
        schema = kw.pop("schema", self.schema)
        metadata = kw.pop("metadata", self.metadata)
        _create_events = kw.pop("_create_events", False)
        return impltype(
            name=self.name,
            schema=schema,
            inherit_schema=self.inherit_schema,
            metadata=metadata,
            _create_events=_create_events,
            **kw
        )

    @property
    def bind(self):
        return self.metadata and self.metadata.bind or None

    def create(self, bind=None, checkfirst=False):
        """Issue CREATE DDL for this type, if applicable."""

        if bind is None:
            bind = _bind_or_error(self)
        t = self.dialect_impl(bind.dialect)
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
            t.create(bind=bind, checkfirst=checkfirst)

    def drop(self, bind=None, checkfirst=False):
        """Issue DROP DDL for this type, if applicable."""

        if bind is None:
            bind = _bind_or_error(self)
        t = self.dialect_impl(bind.dialect)
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
            t.drop(bind=bind, checkfirst=checkfirst)
=======
        return self.adapt(
            cast("Type[TypeEngine[Any]]", self.__class__),
            _create_events=True,
        )

    @overload
    def adapt(self, cls: Type[_TE], **kw: Any) -> _TE: ...

    @overload
    def adapt(
        self, cls: Type[TypeEngineMixin], **kw: Any
    ) -> TypeEngine[Any]: ...

    def adapt(
        self, cls: Type[Union[TypeEngine[Any], TypeEngineMixin]], **kw: Any
    ) -> TypeEngine[Any]:
        kw.setdefault("_create_events", False)
        kw.setdefault("_adapted_from", self)
        return super().adapt(cls, **kw)

    def create(self, bind, checkfirst=False):
        """Issue CREATE DDL for this type, if applicable."""

        t = self.dialect_impl(bind.dialect)
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
            t.create(bind, checkfirst=checkfirst)

    def drop(self, bind, checkfirst=False):
        """Issue DROP DDL for this type, if applicable."""

        t = self.dialect_impl(bind.dialect)
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
            t.drop(bind, checkfirst=checkfirst)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def _on_table_create(self, target, bind, **kw):
        if not self._is_impl_for_variant(bind.dialect, kw):
            return

        t = self.dialect_impl(bind.dialect)
<<<<<<< HEAD
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
=======
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            t._on_table_create(target, bind, **kw)

    def _on_table_drop(self, target, bind, **kw):
        if not self._is_impl_for_variant(bind.dialect, kw):
            return

        t = self.dialect_impl(bind.dialect)
<<<<<<< HEAD
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
=======
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            t._on_table_drop(target, bind, **kw)

    def _on_metadata_create(self, target, bind, **kw):
        if not self._is_impl_for_variant(bind.dialect, kw):
            return

        t = self.dialect_impl(bind.dialect)
<<<<<<< HEAD
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
=======
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            t._on_metadata_create(target, bind, **kw)

    def _on_metadata_drop(self, target, bind, **kw):
        if not self._is_impl_for_variant(bind.dialect, kw):
            return

        t = self.dialect_impl(bind.dialect)
<<<<<<< HEAD
        if t.__class__ is not self.__class__ and isinstance(t, SchemaType):
=======
        if isinstance(t, SchemaType) and t.__class__ is not self.__class__:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            t._on_metadata_drop(target, bind, **kw)

    def _is_impl_for_variant(self, dialect, kw):
        variant_mapping = kw.pop("variant_mapping", None)
<<<<<<< HEAD
        if variant_mapping is None:
            return True

        if (
            dialect.name in variant_mapping
            and variant_mapping[dialect.name] is self
        ):
            return True
        elif dialect.name not in variant_mapping:
            return variant_mapping["_default"] is self


class Enum(Emulated, String, SchemaType):
=======

        if not variant_mapping:
            return True

        # for types that have _variant_mapping, all the impls in the map
        # that are SchemaEventTarget subclasses get set up as event holders.
        # this is so that constructs that need
        # to be associated with the Table at dialect-agnostic time etc. like
        # CheckConstraints can be set up with that table.  they then add
        # to these constraints a DDL check_rule that among other things
        # will check this _is_impl_for_variant() method to determine when
        # the dialect is known that we are part of the table's DDL sequence.

        # since PostgreSQL is the only DB that has ARRAY this can only
        # be integration tested by PG-specific tests
        def _we_are_the_impl(typ):
            return (
                typ is self
                or isinstance(typ, ARRAY)
                and typ.item_type is self  # type: ignore[comparison-overlap]
            )

        if dialect.name in variant_mapping and _we_are_the_impl(
            variant_mapping[dialect.name]
        ):
            return True
        elif dialect.name not in variant_mapping:
            return _we_are_the_impl(variant_mapping["_default"])


class Enum(String, SchemaType, Emulated, TypeEngine[Union[str, enum.Enum]]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """Generic Enum Type.

    The :class:`.Enum` type provides a set of possible string values
    which the column is constrained towards.

    The :class:`.Enum` type will make use of the backend's native "ENUM"
<<<<<<< HEAD
    type if one is available; otherwise, it uses a VARCHAR datatype and
    produces a CHECK constraint.  Use of the backend-native enum type
    can be disabled using the :paramref:`.Enum.native_enum` flag, and
    the production of the CHECK constraint is configurable using the
    :paramref:`.Enum.create_constraint` flag.
=======
    type if one is available; otherwise, it uses a VARCHAR datatype.
    An option also exists to automatically produce a CHECK constraint
    when the VARCHAR (so called "non-native") variant is produced;
    see the  :paramref:`.Enum.create_constraint` flag.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    The :class:`.Enum` type also provides in-Python validation of string
    values during both read and write operations.  When reading a value
    from the database in a result set, the string value is always checked
    against the list of possible values and a ``LookupError`` is raised
    if no match is found.  When passing a value to the database as a
    plain string within a SQL statement, if the
    :paramref:`.Enum.validate_strings` parameter is
    set to True, a ``LookupError`` is raised for any string value that's
    not located in the given list of possible values; note that this
    impacts usage of LIKE expressions with enumerated values (an unusual
    use case).

<<<<<<< HEAD
    .. versionchanged:: 1.1 the :class:`.Enum` type now provides in-Python
       validation of input values as well as on data being returned by
       the database.

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    The source of enumerated values may be a list of string values, or
    alternatively a PEP-435-compliant enumerated class.  For the purposes
    of the :class:`.Enum` datatype, this class need only provide a
    ``__members__`` method.

    When using an enumerated class, the enumerated objects are used
    both for input and output, rather than strings as is the case with
    a plain-string enumerated type::

        import enum
<<<<<<< HEAD
=======
        from sqlalchemy import Enum

>>>>>>> 516a66495 (Reinitialize repository and add files)
        class MyEnum(enum.Enum):
            one = 1
            two = 2
            three = 3

        t = Table(
            'data', MetaData(),
            Column('value', Enum(MyEnum))
        )

        connection.execute(t.insert(), {"value": MyEnum.two})
        assert connection.scalar(t.select()) is MyEnum.two

    Above, the string names of each element, e.g. "one", "two", "three",
    are persisted to the database; the values of the Python Enum, here
    indicated as integers, are **not** used; the value of each enum can
    therefore be any kind of Python object whether or not it is persistable.

    In order to persist the values and not the names, the
    :paramref:`.Enum.values_callable` parameter may be used.   The value of
    this parameter is a user-supplied callable, which  is intended to be used
    with a PEP-435-compliant enumerated class and  returns a list of string
    values to be persisted.   For a simple enumeration that uses string values,
    a callable such as  ``lambda x: [e.value for e in x]`` is sufficient.

<<<<<<< HEAD
    .. versionadded:: 1.1 - support for PEP-435-style enumerated
       classes.


    .. seealso::

=======
    .. seealso::

        :ref:`orm_declarative_mapped_column_enums` - background on using
        the :class:`_sqltypes.Enum` datatype with the ORM's
        :ref:`ORM Annotated Declarative <orm_declarative_mapped_column>`
        feature.

>>>>>>> 516a66495 (Reinitialize repository and add files)
        :class:`_postgresql.ENUM` - PostgreSQL-specific type,
        which has additional functionality.

        :class:`.mysql.ENUM` - MySQL-specific type

    """

    __visit_name__ = "enum"

<<<<<<< HEAD
    @util.deprecated_params(
        convert_unicode=(
            "1.3",
            "The :paramref:`.Enum.convert_unicode` parameter is deprecated "
            "and will be removed in a future release.  All modern DBAPIs "
            "now support Python Unicode directly and this parameter is "
            "unnecessary.",
        )
    )
    def __init__(self, *enums, **kw):
=======
    def __init__(self, *enums: object, **kw: Any):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        r"""Construct an enum.

        Keyword arguments which don't apply to a specific backend are ignored
        by that backend.

        :param \*enums: either exactly one PEP-435 compliant enumerated type
<<<<<<< HEAD
           or one or more string or unicode enumeration labels. If unicode
           labels are present, the `convert_unicode` flag is auto-enabled.

           .. versionadded:: 1.1 a PEP-435 style enumerated class may be
              passed.

        :param convert_unicode: Enable unicode-aware bind parameter and
           result-set processing for this Enum's data. This is set
           automatically based on the presence of unicode label strings.

        :param create_constraint: defaults to True.  When creating a non-native
           enumerated type, also build a CHECK constraint on the database
           against the valid values.

           .. versionadded:: 1.1 - added :paramref:`.Enum.create_constraint`
              which provides the option to disable the production of the
              CHECK constraint for a non-native enumerated type.
=======
           or one or more string labels.

        :param create_constraint: defaults to False.  When creating a
           non-native enumerated type, also build a CHECK constraint on the
           database against the valid values.

           .. note:: it is strongly recommended that the CHECK constraint
              have an explicit name in order to support schema-management
              concerns.  This can be established either by setting the
              :paramref:`.Enum.name` parameter or by setting up an
              appropriate naming convention; see
              :ref:`constraint_naming_conventions` for background.

           .. versionchanged:: 1.4 - this flag now defaults to False, meaning
              no CHECK constraint is generated for a non-native enumerated
              type.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        :param metadata: Associate this type directly with a ``MetaData``
           object. For types that exist on the target database as an
           independent schema construct (PostgreSQL), this type will be
           created and dropped within ``create_all()`` and ``drop_all()``
           operations. If the type is not associated with any ``MetaData``
           object, it will associate itself with each ``Table`` in which it is
           used, and will be created when any of those individual tables are
           created, after a check is performed for its existence. The type is
           only dropped when ``drop_all()`` is called for that ``Table``
           object's metadata, however.

<<<<<<< HEAD
=======
           The value of the :paramref:`_schema.MetaData.schema` parameter of
           the :class:`_schema.MetaData` object, if set, will be used as the
           default value of the :paramref:`_types.Enum.schema` on this object
           if an explicit value is not otherwise supplied.

           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the
              :paramref:`_schema.MetaData.schema` parameter of the
              :class:`_schema.MetaData` object if present, when passed using
              the :paramref:`_types.Enum.metadata` parameter.

>>>>>>> 516a66495 (Reinitialize repository and add files)
        :param name: The name of this type. This is required for PostgreSQL
           and any future supported database which requires an explicitly
           named type, or an explicitly named constraint in order to generate
           the type and/or a table that uses it. If a PEP-435 enumerated
           class was used, its name (converted to lower case) is used by
           default.

        :param native_enum: Use the database's native ENUM type when
           available. Defaults to True. When False, uses VARCHAR + check
<<<<<<< HEAD
           constraint for all backends. The VARCHAR length can be controlled
           with :paramref:`.Enum.length`

        :param length: Allows specifying a custom length for the VARCHAR
           when :paramref:`.Enum.native_enum` is False. By default it uses the
           length of the longest value.

           .. versionadded:: 1.3.16
=======
           constraint for all backends. When False, the VARCHAR length can be
           controlled with :paramref:`.Enum.length`; currently "length" is
           ignored if native_enum=True.

        :param length: Allows specifying a custom length for the VARCHAR
           when a non-native enumeration datatype is used.  By default it uses
           the length of the longest value.

           .. versionchanged:: 2.0.0 The :paramref:`.Enum.length` parameter
              is used unconditionally for ``VARCHAR`` rendering regardless of
              the :paramref:`.Enum.native_enum` parameter, for those backends
              where ``VARCHAR`` is used for enumerated datatypes.

>>>>>>> 516a66495 (Reinitialize repository and add files)

        :param schema: Schema name of this type. For types that exist on the
           target database as an independent schema construct (PostgreSQL),
           this parameter specifies the named schema in which the type is
           present.

<<<<<<< HEAD
           .. note::

                The ``schema`` of the :class:`.Enum` type does not
                by default make use of the ``schema`` established on the
                owning :class:`_schema.Table`.  If this behavior is desired,
                set the ``inherit_schema`` flag to ``True``.
=======
           If not present, the schema name will be taken from the
           :class:`_schema.MetaData` collection if passed as
           :paramref:`_types.Enum.metadata`, for a :class:`_schema.MetaData`
           that includes the :paramref:`_schema.MetaData.schema` parameter.

           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the
              :paramref:`_schema.MetaData.schema` parameter of the
              :class:`_schema.MetaData` object if present, when passed using
              the :paramref:`_types.Enum.metadata` parameter.

           Otherwise, if the :paramref:`_types.Enum.inherit_schema` flag is set
           to ``True``, the schema will be inherited from the associated
           :class:`_schema.Table` object if any; when
           :paramref:`_types.Enum.inherit_schema` is at its default of
           ``False``, the owning table's schema is **not** used.

>>>>>>> 516a66495 (Reinitialize repository and add files)

        :param quote: Set explicit quoting preferences for the type's name.

        :param inherit_schema: When ``True``, the "schema" from the owning
           :class:`_schema.Table`
           will be copied to the "schema" attribute of this
           :class:`.Enum`, replacing whatever value was passed for the
           ``schema`` attribute.   This also takes effect when using the
<<<<<<< HEAD
           :meth:`_schema.Table.tometadata` operation.
=======
           :meth:`_schema.Table.to_metadata` operation.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        :param validate_strings: when True, string values that are being
           passed to the database in a SQL statement will be checked
           for validity against the list of enumerated values.  Unrecognized
           values will result in a ``LookupError`` being raised.

<<<<<<< HEAD
           .. versionadded:: 1.1.0b2

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
        :param values_callable: A callable which will be passed the PEP-435
           compliant enumerated type, which should then return a list of string
           values to be persisted. This allows for alternate usages such as
           using the string value of an enum to be persisted to the database
<<<<<<< HEAD
           instead of its name.
=======
           instead of its name. The callable must return the values to be
           persisted in the same order as iterating through the Enum's
           ``__member__`` attribute. For example
           ``lambda x: [i.value for i in x]``.
>>>>>>> 516a66495 (Reinitialize repository and add files)

           .. versionadded:: 1.2.3

        :param sort_key_function: a Python callable which may be used as the
           "key" argument in the Python ``sorted()`` built-in.   The SQLAlchemy
           ORM requires that primary key columns which are mapped must
           be sortable in some way.  When using an unsortable enumeration
           object such as a Python 3 ``Enum`` object, this parameter may be
           used to set a default sort key function for the objects.  By
           default, the database value of the enumeration is used as the
           sorting function.

           .. versionadded:: 1.3.8

<<<<<<< HEAD

=======
        :param omit_aliases: A boolean that when true will remove aliases from
           pep 435 enums. defaults to ``True``.

           .. versionchanged:: 2.0 This parameter now defaults to True.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        """
        self._enum_init(enums, kw)

    @property
    def _enums_argument(self):
        if self.enum_class is not None:
            return [self.enum_class]
        else:
            return self.enums

    def _enum_init(self, enums, kw):
        """internal init for :class:`.Enum` and subclasses.

        friendly init helper used by subclasses to remove
        all the Enum-specific keyword arguments from kw.  Allows all
        other arguments in kw to pass through.

        """
        self.native_enum = kw.pop("native_enum", True)
<<<<<<< HEAD
        self.create_constraint = kw.pop("create_constraint", True)
        self.values_callable = kw.pop("values_callable", None)
        self._sort_key_function = kw.pop("sort_key_function", NO_ARG)
        length_arg = kw.pop("length", NO_ARG)

        values, objects = self._parse_into_values(enums, kw)
        self._setup_for_values(values, objects, kw)

        convert_unicode = kw.pop("convert_unicode", None)
        self.validate_strings = kw.pop("validate_strings", False)

        if convert_unicode is None:
            for e in self.enums:
                # this is all py2k logic that can go away for py3k only,
                # "expect unicode" will always be implicitly true
                if isinstance(e, util.text_type):
                    _expect_unicode = True
                    break
            else:
                _expect_unicode = False
        else:
            _expect_unicode = convert_unicode

        if self.enums:
            length = max(len(x) for x in self.enums)
        else:
            length = 0
        if not self.native_enum and length_arg is not NO_ARG:
            if length_arg < length:
=======
        self.create_constraint = kw.pop("create_constraint", False)
        self.values_callable = kw.pop("values_callable", None)
        self._sort_key_function = kw.pop("sort_key_function", NO_ARG)
        length_arg = kw.pop("length", NO_ARG)
        self._omit_aliases = kw.pop("omit_aliases", True)
        _disable_warnings = kw.pop("_disable_warnings", False)
        values, objects = self._parse_into_values(enums, kw)
        self._setup_for_values(values, objects, kw)

        self.validate_strings = kw.pop("validate_strings", False)

        if self.enums:
            self._default_length = length = max(len(x) for x in self.enums)
        else:
            self._default_length = length = 0

        if length_arg is not NO_ARG:
            if (
                not _disable_warnings
                and length_arg is not None
                and length_arg < length
            ):
>>>>>>> 516a66495 (Reinitialize repository and add files)
                raise ValueError(
                    "When provided, length must be larger or equal"
                    " than the length of the longest enum value. %s < %s"
                    % (length_arg, length)
                )
            length = length_arg

        self._valid_lookup[None] = self._object_lookup[None] = None

<<<<<<< HEAD
        super(Enum, self).__init__(
            length=length, _expect_unicode=_expect_unicode
        )

        if self.enum_class:
=======
        super().__init__(length=length)

        # assign name to the given enum class if no other name, and this
        # enum is not an "empty" enum.  if the enum is "empty" we assume
        # this is a template enum that will be used to generate
        # new Enum classes.
        if self.enum_class and values:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            kw.setdefault("name", self.enum_class.__name__.lower())
        SchemaType.__init__(
            self,
            name=kw.pop("name", None),
            schema=kw.pop("schema", None),
            metadata=kw.pop("metadata", None),
            inherit_schema=kw.pop("inherit_schema", False),
            quote=kw.pop("quote", None),
            _create_events=kw.pop("_create_events", True),
<<<<<<< HEAD
=======
            _adapted_from=kw.pop("_adapted_from", None),
>>>>>>> 516a66495 (Reinitialize repository and add files)
        )

    def _parse_into_values(self, enums, kw):
        if not enums and "_enums" in kw:
            enums = kw.pop("_enums")

        if len(enums) == 1 and hasattr(enums[0], "__members__"):
            self.enum_class = enums[0]
<<<<<<< HEAD
            members = self.enum_class.__members__
=======

            _members = self.enum_class.__members__

            if self._omit_aliases is True:
                # remove aliases
                members = OrderedDict(
                    (n, v) for n, v in _members.items() if v.name == n
                )
            else:
                members = _members
>>>>>>> 516a66495 (Reinitialize repository and add files)
            if self.values_callable:
                values = self.values_callable(self.enum_class)
            else:
                values = list(members)
            objects = [members[k] for k in members]
            return values, objects
        else:
            self.enum_class = None
            return enums, enums

<<<<<<< HEAD
=======
    def _resolve_for_literal(self, value: Any) -> Enum:
        tv = type(value)
        typ = self._resolve_for_python_type(tv, tv, tv)
        assert typ is not None
        return typ

    def _resolve_for_python_type(
        self,
        python_type: Type[Any],
        matched_on: _MatchedOnType,
        matched_on_flattened: Type[Any],
    ) -> Optional[Enum]:
        # "generic form" indicates we were placed in a type map
        # as ``sqlalchemy.Enum(enum.Enum)`` which indicates we need to
        # get enumerated values from the datatype
        we_are_generic_form = self._enums_argument == [enum.Enum]

        native_enum = None

        if not we_are_generic_form and python_type is matched_on:
            # if we have enumerated values, and the incoming python
            # type is exactly the one that matched in the type map,
            # then we use these enumerated values and dont try to parse
            # what's incoming
            enum_args = self._enums_argument

        elif is_literal(python_type):
            # for a literal, where we need to get its contents, parse it out.
            enum_args = typing_get_args(python_type)
            bad_args = [arg for arg in enum_args if not isinstance(arg, str)]
            if bad_args:
                raise exc.ArgumentError(
                    f"Can't create string-based Enum datatype from non-string "
                    f"values: {', '.join(repr(x) for x in bad_args)}.  Please "
                    f"provide an explicit Enum datatype for this Python type"
                )
            native_enum = False
        elif isinstance(python_type, type) and issubclass(
            python_type, enum.Enum
        ):
            # same for an enum.Enum
            enum_args = [python_type]

        else:
            enum_args = self._enums_argument

        # make a new Enum that looks like this one.
        # arguments or other rules
        kw = self._make_enum_kw({})

        if native_enum is False:
            kw["native_enum"] = False

        kw["length"] = NO_ARG if self.length == 0 else self.length
        return cast(
            Enum,
            self._generic_type_affinity(_enums=enum_args, **kw),  # type: ignore  # noqa: E501
        )

>>>>>>> 516a66495 (Reinitialize repository and add files)
    def _setup_for_values(self, values, objects, kw):
        self.enums = list(values)

        self._valid_lookup = dict(zip(reversed(objects), reversed(values)))

        self._object_lookup = dict(zip(values, objects))

        self._valid_lookup.update(
            [
                (value, self._valid_lookup[self._object_lookup[value]])
                for value in values
            ]
        )

    @property
    def sort_key_function(self):
        if self._sort_key_function is NO_ARG:
            return self._db_value_for_elem
        else:
            return self._sort_key_function

    @property
    def native(self):
        return self.native_enum

    def _db_value_for_elem(self, elem):
        try:
            return self._valid_lookup[elem]
        except KeyError as err:
            # for unknown string values, we return as is.  While we can
            # validate these if we wanted, that does not allow for lesser-used
            # end-user use cases, such as using a LIKE comparison with an enum,
            # or for an application that wishes to apply string tests to an
            # ENUM (see [ticket:3725]).  While we can decide to differentiate
            # here between an INSERT statement and a criteria used in a SELECT,
            # for now we're staying conservative w/ behavioral changes (perhaps
            # someone has a trigger that handles strings on INSERT)
<<<<<<< HEAD
            if not self.validate_strings and isinstance(
                elem, compat.string_types
            ):
                return elem
            else:
                util.raise_(
                    LookupError(
                        "'%s' is not among the defined enum values. "
                        "Enum name: %s. Possible values: %s"
                        % (
                            elem,
                            self.name,
                            langhelpers.repr_tuple_names(self.enums),
                        )
                    ),
                    replace_context=err,
                )

    class Comparator(String.Comparator):
        def _adapt_expression(self, op, other_comparator):
            op, typ = super(Enum.Comparator, self)._adapt_expression(
                op, other_comparator
            )
            if op is operators.concat_op:
                typ = String(
                    self.type.length, _expect_unicode=self.type._expect_unicode
                )
=======
            if not self.validate_strings and isinstance(elem, str):
                return elem
            else:
                raise LookupError(
                    "'%s' is not among the defined enum values. "
                    "Enum name: %s. Possible values: %s"
                    % (
                        elem,
                        self.name,
                        langhelpers.repr_tuple_names(self.enums),
                    )
                ) from err

    class Comparator(String.Comparator[str]):
        __slots__ = ()

        type: String

        def _adapt_expression(
            self,
            op: OperatorType,
            other_comparator: TypeEngine.Comparator[Any],
        ) -> Tuple[OperatorType, TypeEngine[Any]]:
            op, typ = super()._adapt_expression(op, other_comparator)
            if op is operators.concat_op:
                typ = String(self.type.length)
>>>>>>> 516a66495 (Reinitialize repository and add files)
            return op, typ

    comparator_factory = Comparator

    def _object_value_for_elem(self, elem):
        try:
            return self._object_lookup[elem]
        except KeyError as err:
<<<<<<< HEAD
            util.raise_(
                LookupError(
                    "'%s' is not among the defined enum values. "
                    "Enum name: %s. Possible values: %s"
                    % (
                        elem,
                        self.name,
                        langhelpers.repr_tuple_names(self.enums),
                    )
                ),
                replace_context=err,
            )
=======
            raise LookupError(
                "'%s' is not among the defined enum values. "
                "Enum name: %s. Possible values: %s"
                % (
                    elem,
                    self.name,
                    langhelpers.repr_tuple_names(self.enums),
                )
            ) from err
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def __repr__(self):
        return util.generic_repr(
            self,
<<<<<<< HEAD
            additional_kw=[("native_enum", True)],
            to_inspect=[Enum, SchemaType],
        )

    def adapt_to_emulated(self, impltype, **kw):
        kw.setdefault("_expect_unicode", self._expect_unicode)
        kw.setdefault("validate_strings", self.validate_strings)
        kw.setdefault("name", self.name)
        kw.setdefault("schema", self.schema)
        kw.setdefault("inherit_schema", self.inherit_schema)
        kw.setdefault("metadata", self.metadata)
        kw.setdefault("_create_events", False)
=======
            additional_kw=[
                ("native_enum", True),
                ("create_constraint", False),
                ("length", self._default_length),
            ],
            to_inspect=[Enum, SchemaType],
        )

    def as_generic(self, allow_nulltype=False):
        try:
            args = self.enums
        except AttributeError:
            raise NotImplementedError(
                "TypeEngine.as_generic() heuristic "
                "is undefined for types that inherit Enum but do not have "
                "an `enums` attribute."
            ) from None

        return util.constructor_copy(
            self, self._generic_type_affinity, *args, _disable_warnings=True
        )

    def _make_enum_kw(self, kw):
        kw.setdefault("validate_strings", self.validate_strings)
        if self.name:
            kw.setdefault("name", self.name)
        kw.setdefault("schema", self.schema)
        kw.setdefault("inherit_schema", self.inherit_schema)
        kw.setdefault("metadata", self.metadata)
>>>>>>> 516a66495 (Reinitialize repository and add files)
        kw.setdefault("native_enum", self.native_enum)
        kw.setdefault("values_callable", self.values_callable)
        kw.setdefault("create_constraint", self.create_constraint)
        kw.setdefault("length", self.length)
<<<<<<< HEAD
=======
        kw.setdefault("omit_aliases", self._omit_aliases)
        return kw

    def adapt_to_emulated(self, impltype, **kw):
        self._make_enum_kw(kw)
        kw["_disable_warnings"] = True
        kw.setdefault("_create_events", False)
>>>>>>> 516a66495 (Reinitialize repository and add files)
        assert "_enums" in kw
        return impltype(**kw)

    def adapt(self, impltype, **kw):
        kw["_enums"] = self._enums_argument
<<<<<<< HEAD
        return super(Enum, self).adapt(impltype, **kw)
=======
        kw["_disable_warnings"] = True
        return super().adapt(impltype, **kw)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def _should_create_constraint(self, compiler, **kw):
        if not self._is_impl_for_variant(compiler.dialect, kw):
            return False
        return (
            not self.native_enum or not compiler.dialect.supports_native_enum
        )

<<<<<<< HEAD
    @util.dependencies("sqlalchemy.sql.schema")
    def _set_table(self, schema, column, table):
=======
    @util.preload_module("sqlalchemy.sql.schema")
    def _set_table(self, column, table):
        schema = util.preloaded.sql_schema
>>>>>>> 516a66495 (Reinitialize repository and add files)
        SchemaType._set_table(self, column, table)

        if not self.create_constraint:
            return

        variant_mapping = self._variant_mapping_for_set_table(column)

        e = schema.CheckConstraint(
<<<<<<< HEAD
            type_coerce(column, self).in_(self.enums),
=======
            type_coerce(column, String()).in_(self.enums),
>>>>>>> 516a66495 (Reinitialize repository and add files)
            name=_NONE_NAME if self.name is None else self.name,
            _create_rule=util.portable_instancemethod(
                self._should_create_constraint,
                {"variant_mapping": variant_mapping},
            ),
            _type_bound=True,
        )
        assert e.table is table

    def literal_processor(self, dialect):
<<<<<<< HEAD
        parent_processor = super(Enum, self).literal_processor(dialect)
=======
        parent_processor = super().literal_processor(dialect)
>>>>>>> 516a66495 (Reinitialize repository and add files)

        def process(value):
            value = self._db_value_for_elem(value)
            if parent_processor:
                value = parent_processor(value)
            return value

        return process

    def bind_processor(self, dialect):
<<<<<<< HEAD
=======
        parent_processor = super().bind_processor(dialect)

>>>>>>> 516a66495 (Reinitialize repository and add files)
        def process(value):
            value = self._db_value_for_elem(value)
            if parent_processor:
                value = parent_processor(value)
            return value

<<<<<<< HEAD
        parent_processor = super(Enum, self).bind_processor(dialect)
        return process

    def result_processor(self, dialect, coltype):
        parent_processor = super(Enum, self).result_processor(dialect, coltype)
=======
        return process

    def result_processor(self, dialect, coltype):
        parent_processor = super().result_processor(dialect, coltype)
>>>>>>> 516a66495 (Reinitialize repository and add files)

        def process(value):
            if parent_processor:
                value = parent_processor(value)

            value = self._object_value_for_elem(value)
            return value

        return process

    def copy(self, **kw):
        return SchemaType.copy(self, **kw)

    @property
    def python_type(self):
        if self.enum_class:
            return self.enum_class
        else:
<<<<<<< HEAD
            return super(Enum, self).python_type


class PickleType(TypeDecorator):
=======
            return super().python_type


class PickleType(TypeDecorator[object]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """Holds Python objects, which are serialized using pickle.

    PickleType builds upon the Binary type to apply Python's
    ``pickle.dumps()`` to incoming objects, and ``pickle.loads()`` on
    the way out, allowing any pickleable Python object to be stored as
    a serialized binary field.

    To allow ORM change events to propagate for elements associated
    with :class:`.PickleType`, see :ref:`mutable_toplevel`.

    """

    impl = LargeBinary
<<<<<<< HEAD

    def __init__(
        self, protocol=pickle.HIGHEST_PROTOCOL, pickler=None, comparator=None
=======
    cache_ok = True

    def __init__(
        self,
        protocol: int = pickle.HIGHEST_PROTOCOL,
        pickler: Any = None,
        comparator: Optional[Callable[[Any, Any], bool]] = None,
        impl: Optional[_TypeEngineArgument[Any]] = None,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        """
        Construct a PickleType.

        :param protocol: defaults to ``pickle.HIGHEST_PROTOCOL``.

<<<<<<< HEAD
        :param pickler: defaults to cPickle.pickle or pickle.pickle if
          cPickle is not available.  May be any object with
=======
        :param pickler: defaults to pickle.  May be any object with
>>>>>>> 516a66495 (Reinitialize repository and add files)
          pickle-compatible ``dumps`` and ``loads`` methods.

        :param comparator: a 2-arg callable predicate used
          to compare values of this type.  If left as ``None``,
          the Python "equals" operator is used to compare values.

<<<<<<< HEAD
=======
        :param impl: A binary-storing :class:`_types.TypeEngine` class or
          instance to use in place of the default :class:`_types.LargeBinary`.
          For example the :class: `_mysql.LONGBLOB` class may be more effective
          when using MySQL.

          .. versionadded:: 1.4.20

>>>>>>> 516a66495 (Reinitialize repository and add files)
        """
        self.protocol = protocol
        self.pickler = pickler or pickle
        self.comparator = comparator
<<<<<<< HEAD
        super(PickleType, self).__init__()
=======
        super().__init__()

        if impl:
            # custom impl is not necessarily a LargeBinary subclass.
            # make an exception to typing for this
            self.impl = to_instance(impl)  # type: ignore
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def __reduce__(self):
        return PickleType, (self.protocol, None, self.comparator)

    def bind_processor(self, dialect):
<<<<<<< HEAD
        impl_processor = self.impl.bind_processor(dialect)
        dumps = self.pickler.dumps
        protocol = self.protocol
        if impl_processor:
=======
        impl_processor = self.impl_instance.bind_processor(dialect)
        dumps = self.pickler.dumps
        protocol = self.protocol
        if impl_processor:
            fixed_impl_processor = impl_processor
>>>>>>> 516a66495 (Reinitialize repository and add files)

            def process(value):
                if value is not None:
                    value = dumps(value, protocol)
<<<<<<< HEAD
                return impl_processor(value)
=======
                return fixed_impl_processor(value)
>>>>>>> 516a66495 (Reinitialize repository and add files)

        else:

            def process(value):
                if value is not None:
                    value = dumps(value, protocol)
                return value

        return process

    def result_processor(self, dialect, coltype):
<<<<<<< HEAD
        impl_processor = self.impl.result_processor(dialect, coltype)
        loads = self.pickler.loads
        if impl_processor:

            def process(value):
                value = impl_processor(value)
=======
        impl_processor = self.impl_instance.result_processor(dialect, coltype)
        loads = self.pickler.loads
        if impl_processor:
            fixed_impl_processor = impl_processor

            def process(value):
                value = fixed_impl_processor(value)
>>>>>>> 516a66495 (Reinitialize repository and add files)
                if value is None:
                    return None
                return loads(value)

        else:

            def process(value):
                if value is None:
                    return None
                return loads(value)

        return process

    def compare_values(self, x, y):
        if self.comparator:
            return self.comparator(x, y)
        else:
            return x == y


<<<<<<< HEAD
class Boolean(Emulated, TypeEngine, SchemaType):

=======
class Boolean(SchemaType, Emulated, TypeEngine[bool]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A bool datatype.

    :class:`.Boolean` typically uses BOOLEAN or SMALLINT on the DDL side,
    and on the Python side deals in ``True`` or ``False``.

    The :class:`.Boolean` datatype currently has two levels of assertion
    that the values persisted are simple true/false values.  For all
    backends, only the Python values ``None``, ``True``, ``False``, ``1``
    or ``0`` are accepted as parameter values.   For those backends that
<<<<<<< HEAD
    don't support a "native boolean" datatype, a CHECK constraint is also
    created on the target column.   Production of the CHECK constraint
    can be disabled by passing the :paramref:`.Boolean.create_constraint`
    flag set to ``False``.
=======
    don't support a "native boolean" datatype, an option exists to
    also create a CHECK constraint on the target column
>>>>>>> 516a66495 (Reinitialize repository and add files)

    .. versionchanged:: 1.2 the :class:`.Boolean` datatype now asserts that
       incoming Python values are already in pure boolean form.


    """

    __visit_name__ = "boolean"
    native = True

<<<<<<< HEAD
    def __init__(self, create_constraint=True, name=None, _create_events=True):
        """Construct a Boolean.

        :param create_constraint: defaults to True.  If the boolean
          is generated as an int/smallint, also create a CHECK constraint
          on the table that ensures 1 or 0 as a value.

=======
    def __init__(
        self,
        create_constraint: bool = False,
        name: Optional[str] = None,
        _create_events: bool = True,
        _adapted_from: Optional[SchemaType] = None,
    ):
        """Construct a Boolean.

        :param create_constraint: defaults to False.  If the boolean
          is generated as an int/smallint, also create a CHECK constraint
          on the table that ensures 1 or 0 as a value.

          .. note:: it is strongly recommended that the CHECK constraint
             have an explicit name in order to support schema-management
             concerns.  This can be established either by setting the
             :paramref:`.Boolean.name` parameter or by setting up an
             appropriate naming convention; see
             :ref:`constraint_naming_conventions` for background.

          .. versionchanged:: 1.4 - this flag now defaults to False, meaning
             no CHECK constraint is generated for a non-native enumerated
             type.

>>>>>>> 516a66495 (Reinitialize repository and add files)
        :param name: if a CHECK constraint is generated, specify
          the name of the constraint.

        """
        self.create_constraint = create_constraint
        self.name = name
        self._create_events = _create_events
<<<<<<< HEAD
=======
        if _adapted_from:
            self.dispatch = self.dispatch._join(_adapted_from.dispatch)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def _should_create_constraint(self, compiler, **kw):
        if not self._is_impl_for_variant(compiler.dialect, kw):
            return False
        return (
            not compiler.dialect.supports_native_boolean
            and compiler.dialect.non_native_boolean_check_constraint
        )

<<<<<<< HEAD
    @util.dependencies("sqlalchemy.sql.schema")
    def _set_table(self, schema, column, table):
=======
    @util.preload_module("sqlalchemy.sql.schema")
    def _set_table(self, column, table):
        schema = util.preloaded.sql_schema
>>>>>>> 516a66495 (Reinitialize repository and add files)
        if not self.create_constraint:
            return

        variant_mapping = self._variant_mapping_for_set_table(column)

        e = schema.CheckConstraint(
            type_coerce(column, self).in_([0, 1]),
            name=_NONE_NAME if self.name is None else self.name,
            _create_rule=util.portable_instancemethod(
                self._should_create_constraint,
                {"variant_mapping": variant_mapping},
            ),
            _type_bound=True,
        )
        assert e.table is table

    @property
    def python_type(self):
        return bool

    _strict_bools = frozenset([None, True, False])

    def _strict_as_bool(self, value):
        if value not in self._strict_bools:
            if not isinstance(value, int):
<<<<<<< HEAD
                raise TypeError("Not a boolean value: %r" % value)
            else:
                raise ValueError(
                    "Value %r is not None, True, or False" % value
=======
                raise TypeError("Not a boolean value: %r" % (value,))
            else:
                raise ValueError(
                    "Value %r is not None, True, or False" % (value,)
>>>>>>> 516a66495 (Reinitialize repository and add files)
                )
        return value

    def literal_processor(self, dialect):
        compiler = dialect.statement_compiler(dialect, None)
        true = compiler.visit_true(None)
        false = compiler.visit_false(None)

        def process(value):
            return true if self._strict_as_bool(value) else false

        return process

    def bind_processor(self, dialect):
        _strict_as_bool = self._strict_as_bool
<<<<<<< HEAD
=======

        _coerce: Union[Type[bool], Type[int]]

>>>>>>> 516a66495 (Reinitialize repository and add files)
        if dialect.supports_native_boolean:
            _coerce = bool
        else:
            _coerce = int

        def process(value):
            value = _strict_as_bool(value)
            if value is not None:
                value = _coerce(value)
            return value

        return process

    def result_processor(self, dialect, coltype):
        if dialect.supports_native_boolean:
            return None
        else:
            return processors.int_to_boolean


<<<<<<< HEAD
class _AbstractInterval(_LookupExpressionAdapter, TypeEngine):
    @util.memoized_property
    def _expression_adaptations(self):
        # Based on http://www.postgresql.org/docs/current/\
        # static/functions-datetime.html.
=======
class _AbstractInterval(HasExpressionLookup, TypeEngine[dt.timedelta]):
    @util.memoized_property
    def _expression_adaptations(self):
        # Based on
        # https://www.postgresql.org/docs/current/static/functions-datetime.html.
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return {
            operators.add: {
                Date: DateTime,
                Interval: self.__class__,
                DateTime: DateTime,
                Time: Time,
            },
            operators.sub: {Interval: self.__class__},
            operators.mul: {Numeric: self.__class__},
            operators.truediv: {Numeric: self.__class__},
<<<<<<< HEAD
            operators.div: {Numeric: self.__class__},
        }

    @property
    def _type_affinity(self):
        return Interval

    def coerce_compared_value(self, op, value):
        """See :meth:`.TypeEngine.coerce_compared_value` for a description."""
        return self.impl.coerce_compared_value(op, value)


class Interval(Emulated, _AbstractInterval, TypeDecorator):

    """A type for ``datetime.timedelta()`` objects.

    The Interval type deals with ``datetime.timedelta`` objects.  In
    PostgreSQL, the native ``INTERVAL`` type is used; for others, the
    value is stored as a date which is relative to the "epoch"
=======
        }

    @util.ro_non_memoized_property
    def _type_affinity(self) -> Type[Interval]:
        return Interval


class Interval(Emulated, _AbstractInterval, TypeDecorator[dt.timedelta]):
    """A type for ``datetime.timedelta()`` objects.

    The Interval type deals with ``datetime.timedelta`` objects.  In
    PostgreSQL and Oracle, the native ``INTERVAL`` type is used; for others,
    the value is stored as a date which is relative to the "epoch"
>>>>>>> 516a66495 (Reinitialize repository and add files)
    (Jan. 1, 1970).

    Note that the ``Interval`` type does not currently provide date arithmetic
    operations on platforms which do not support interval types natively. Such
    operations usually require transformation of both sides of the expression
    (such as, conversion of both sides into integer epoch values first) which
    currently is a manual procedure (such as via
    :attr:`~sqlalchemy.sql.expression.func`).

    """

    impl = DateTime
<<<<<<< HEAD
    epoch = dt.datetime.utcfromtimestamp(0)

    def __init__(self, native=True, second_precision=None, day_precision=None):
=======
    epoch = dt.datetime.fromtimestamp(0, dt.timezone.utc).replace(tzinfo=None)
    cache_ok = True

    def __init__(
        self,
        native: bool = True,
        second_precision: Optional[int] = None,
        day_precision: Optional[int] = None,
    ):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Construct an Interval object.

        :param native: when True, use the actual
          INTERVAL type provided by the database, if
          supported (currently PostgreSQL, Oracle).
          Otherwise, represent the interval data as
          an epoch value regardless.

        :param second_precision: For native interval types
          which support a "fractional seconds precision" parameter,
          i.e. Oracle and PostgreSQL

        :param day_precision: for native interval types which
          support a "day precision" parameter, i.e. Oracle.

        """
<<<<<<< HEAD
        super(Interval, self).__init__()
=======
        super().__init__()
>>>>>>> 516a66495 (Reinitialize repository and add files)
        self.native = native
        self.second_precision = second_precision
        self.day_precision = day_precision

<<<<<<< HEAD
=======
    class Comparator(
        TypeDecorator.Comparator[_CT],
        _AbstractInterval.Comparator[_CT],
    ):
        __slots__ = ()

    comparator_factory = Comparator

>>>>>>> 516a66495 (Reinitialize repository and add files)
    @property
    def python_type(self):
        return dt.timedelta

    def adapt_to_emulated(self, impltype, **kw):
        return _AbstractInterval.adapt(self, impltype, **kw)

<<<<<<< HEAD
    def bind_processor(self, dialect):
        impl_processor = self.impl.bind_processor(dialect)
        epoch = self.epoch
        if impl_processor:

            def process(value):
                if value is not None:
                    value = epoch + value
                return impl_processor(value)

        else:

            def process(value):
                if value is not None:
                    value = epoch + value
                return value

        return process

    def result_processor(self, dialect, coltype):
        impl_processor = self.impl.result_processor(dialect, coltype)
        epoch = self.epoch
        if impl_processor:

            def process(value):
                value = impl_processor(value)
                if value is None:
                    return None
                return value - epoch

        else:

            def process(value):
                if value is None:
                    return None
                return value - epoch
=======
    def coerce_compared_value(self, op, value):
        return self.impl_instance.coerce_compared_value(op, value)

    def bind_processor(
        self, dialect: Dialect
    ) -> _BindProcessorType[dt.timedelta]:
        if TYPE_CHECKING:
            assert isinstance(self.impl_instance, DateTime)
        impl_processor = self.impl_instance.bind_processor(dialect)
        epoch = self.epoch
        if impl_processor:
            fixed_impl_processor = impl_processor

            def process(
                value: Optional[dt.timedelta],
            ) -> Any:
                if value is not None:
                    dt_value = epoch + value
                else:
                    dt_value = None
                return fixed_impl_processor(dt_value)

        else:

            def process(
                value: Optional[dt.timedelta],
            ) -> Any:
                if value is not None:
                    dt_value = epoch + value
                else:
                    dt_value = None
                return dt_value

        return process

    def result_processor(
        self, dialect: Dialect, coltype: Any
    ) -> _ResultProcessorType[dt.timedelta]:
        if TYPE_CHECKING:
            assert isinstance(self.impl_instance, DateTime)
        impl_processor = self.impl_instance.result_processor(dialect, coltype)
        epoch = self.epoch
        if impl_processor:
            fixed_impl_processor = impl_processor

            def process(value: Any) -> Optional[dt.timedelta]:
                dt_value = fixed_impl_processor(value)
                if dt_value is None:
                    return None
                return dt_value - epoch

        else:

            def process(value: Any) -> Optional[dt.timedelta]:
                if value is None:
                    return None
                return value - epoch  # type: ignore
>>>>>>> 516a66495 (Reinitialize repository and add files)

        return process


<<<<<<< HEAD
class JSON(Indexable, TypeEngine):
=======
class JSON(Indexable, TypeEngine[Any]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """Represent a SQL JSON type.

    .. note::  :class:`_types.JSON`
       is provided as a facade for vendor-specific
       JSON types.  Since it supports JSON SQL operations, it only
       works on backends that have an actual JSON type, currently:

<<<<<<< HEAD
       * PostgreSQL

       * MySQL as of version 5.7 (MariaDB as of the 10.2 series does not)

       * SQLite as of version 3.9
=======
       * PostgreSQL - see :class:`sqlalchemy.dialects.postgresql.JSON` and
         :class:`sqlalchemy.dialects.postgresql.JSONB` for backend-specific
         notes

       * MySQL - see
         :class:`sqlalchemy.dialects.mysql.JSON` for backend-specific notes

       * SQLite as of version 3.9 - see
         :class:`sqlalchemy.dialects.sqlite.JSON` for backend-specific notes

       * Microsoft SQL Server 2016 and later - see
         :class:`sqlalchemy.dialects.mssql.JSON` for backend-specific notes
>>>>>>> 516a66495 (Reinitialize repository and add files)

    :class:`_types.JSON` is part of the Core in support of the growing
    popularity of native JSON datatypes.

    The :class:`_types.JSON` type stores arbitrary JSON format data, e.g.::

        data_table = Table('data_table', metadata,
            Column('id', Integer, primary_key=True),
            Column('data', JSON)
        )

        with engine.connect() as conn:
            conn.execute(
                data_table.insert(),
<<<<<<< HEAD
                data = {"key1": "value1", "key2": "value2"}
=======
                {"data": {"key1": "value1", "key2": "value2"}}
>>>>>>> 516a66495 (Reinitialize repository and add files)
            )

    **JSON-Specific Expression Operators**

    The :class:`_types.JSON`
    datatype provides these additional SQL operations:

    * Keyed index operations::

        data_table.c.data['some key']

    * Integer index operations::

        data_table.c.data[3]

    * Path index operations::

        data_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')]

    * Data casters for specific JSON element types, subsequent to an index
      or path operation being invoked::

        data_table.c.data["some key"].as_integer()

      .. versionadded:: 1.3.11

    Additional operations may be available from the dialect-specific versions
<<<<<<< HEAD
    of :class:`_types.JSON`, such as :class:`_postgresql.JSON` and
    :class:`_postgresql.JSONB` which both offer additional PostgreSQL-specific
    operations.
=======
    of :class:`_types.JSON`, such as
    :class:`sqlalchemy.dialects.postgresql.JSON` and
    :class:`sqlalchemy.dialects.postgresql.JSONB` which both offer additional
    PostgreSQL-specific operations.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    **Casting JSON Elements to Other Types**

    Index operations, i.e. those invoked by calling upon the expression using
    the Python bracket operator as in ``some_column['some key']``, return an
    expression object whose type defaults to :class:`_types.JSON` by default,
    so that
    further JSON-oriented instructions may be called upon the result type.
    However, it is likely more common that an index operation is expected
    to return a specific scalar element, such as a string or integer.  In
    order to provide access to these elements in a backend-agnostic way,
    a series of data casters are provided:

    * :meth:`.JSON.Comparator.as_string` - return the element as a string

    * :meth:`.JSON.Comparator.as_boolean` - return the element as a boolean

    * :meth:`.JSON.Comparator.as_float` - return the element as a float

    * :meth:`.JSON.Comparator.as_integer` - return the element as an integer

    These data casters are implemented by supporting dialects in order to
    assure that comparisons to the above types will work as expected, such as::

        # integer comparison
        data_table.c.data["some_integer_key"].as_integer() == 5

        # boolean comparison
        data_table.c.data["some_boolean"].as_boolean() == True

    .. versionadded:: 1.3.11 Added type-specific casters for the basic JSON
       data element types.

    .. note::

        The data caster functions are new in version 1.3.11, and supersede
        the previous documented approaches of using CAST; for reference,
        this looked like::

           from sqlalchemy import cast, type_coerce
           from sqlalchemy import String, JSON
           cast(
               data_table.c.data['some_key'], String
           ) == type_coerce(55, JSON)

        The above case now works directly as::

            data_table.c.data['some_key'].as_integer() == 5

        For details on the previous comparison approach within the 1.3.x
        series, see the documentation for SQLAlchemy 1.2 or the included HTML
        files in the doc/ directory of the version's distribution.

    **Detecting Changes in JSON columns when using the ORM**

    The :class:`_types.JSON` type, when used with the SQLAlchemy ORM, does not
    detect in-place mutations to the structure.  In order to detect these, the
<<<<<<< HEAD
    :mod:`sqlalchemy.ext.mutable` extension must be used.  This extension will
=======
    :mod:`sqlalchemy.ext.mutable` extension must be used, most typically
    using the :class:`.MutableDict` class.  This extension will
>>>>>>> 516a66495 (Reinitialize repository and add files)
    allow "in-place" changes to the datastructure to produce events which
    will be detected by the unit of work.  See the example at :class:`.HSTORE`
    for a simple example involving a dictionary.

<<<<<<< HEAD
    **Support for JSON null vs. SQL NULL**

    When working with NULL values, the :class:`_types.JSON`
    type recommends the
    use of two specific constants in order to differentiate between a column
    that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string
    of ``"null"``.   To insert or select against a value that is SQL NULL,
    use the constant :func:`.null`::

        from sqlalchemy import null
        conn.execute(table.insert(), json_value=null())
=======
    Alternatively, assigning a JSON structure to an ORM element that
    replaces the old one will always trigger a change event.

    **Support for JSON null vs. SQL NULL**

    When working with NULL values, the :class:`_types.JSON` type recommends the
    use of two specific constants in order to differentiate between a column
    that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string of
    ``"null"``. To insert or select against a value that is SQL NULL, use the
    constant :func:`.null`. This symbol may be passed as a parameter value
    specifically when using the :class:`_types.JSON` datatype, which contains
    special logic that interprets this symbol to mean that the column value
    should be SQL NULL as opposed to JSON ``"null"``::

        from sqlalchemy import null
        conn.execute(table.insert(), {"json_value": null()})
>>>>>>> 516a66495 (Reinitialize repository and add files)

    To insert or select against a value that is JSON ``"null"``, use the
    constant :attr:`_types.JSON.NULL`::

<<<<<<< HEAD
        conn.execute(table.insert(), json_value=JSON.NULL)
=======
        conn.execute(table.insert(), {"json_value": JSON.NULL})
>>>>>>> 516a66495 (Reinitialize repository and add files)

    The :class:`_types.JSON` type supports a flag
    :paramref:`_types.JSON.none_as_null` which when set to True will result
    in the Python constant ``None`` evaluating to the value of SQL
    NULL, and when set to False results in the Python constant
    ``None`` evaluating to the value of JSON ``"null"``.    The Python
    value ``None`` may be used in conjunction with either
    :attr:`_types.JSON.NULL` and :func:`.null` in order to indicate NULL
    values, but care must be taken as to the value of the
    :paramref:`_types.JSON.none_as_null` in these cases.

    **Customizing the JSON Serializer**

    The JSON serializer and deserializer used by :class:`_types.JSON`
    defaults to
    Python's ``json.dumps`` and ``json.loads`` functions; in the case of the
    psycopg2 dialect, psycopg2 may be using its own custom loader function.

    In order to affect the serializer / deserializer, they are currently
    configurable at the :func:`_sa.create_engine` level via the
    :paramref:`_sa.create_engine.json_serializer` and
    :paramref:`_sa.create_engine.json_deserializer` parameters.  For example,
    to turn off ``ensure_ascii``::

        engine = create_engine(
            "sqlite://",
            json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False))

    .. versionchanged:: 1.3.7

        SQLite dialect's ``json_serializer`` and ``json_deserializer``
        parameters renamed from ``_json_serializer`` and
        ``_json_deserializer``.

    .. seealso::

<<<<<<< HEAD
        :class:`_postgresql.JSON`

        :class:`_postgresql.JSONB`

        :class:`.mysql.JSON`

        :class:`_sqlite.JSON`

    .. versionadded:: 1.1

=======
        :class:`sqlalchemy.dialects.postgresql.JSON`

        :class:`sqlalchemy.dialects.postgresql.JSONB`

        :class:`sqlalchemy.dialects.mysql.JSON`

        :class:`sqlalchemy.dialects.sqlite.JSON`
>>>>>>> 516a66495 (Reinitialize repository and add files)

    """

    __visit_name__ = "JSON"

    hashable = False
    NULL = util.symbol("JSON_NULL")
    """Describe the json value of NULL.

    This value is used to force the JSON value of ``"null"`` to be
    used as the value.   A value of Python ``None`` will be recognized
    either as SQL NULL or JSON ``"null"``, based on the setting
    of the :paramref:`_types.JSON.none_as_null` flag; the
    :attr:`_types.JSON.NULL`
    constant can be used to always resolve to JSON ``"null"`` regardless
    of this setting.  This is in contrast to the :func:`_expression.null`
    construct,
    which always resolves to SQL NULL.  E.g.::

        from sqlalchemy import null
        from sqlalchemy.dialects.postgresql import JSON

        # will *always* insert SQL NULL
        obj1 = MyObject(json_value=null())

        # will *always* insert JSON string "null"
        obj2 = MyObject(json_value=JSON.NULL)

        session.add_all([obj1, obj2])
        session.commit()

    In order to set JSON NULL as a default value for a column, the most
    transparent method is to use :func:`_expression.text`::

        Table(
            'my_table', metadata,
            Column('json_data', JSON, default=text("'null'"))
        )

    While it is possible to use :attr:`_types.JSON.NULL` in this context, the
    :attr:`_types.JSON.NULL` value will be returned as the value of the
    column,
    which in the context of the ORM or other repurposing of the default
    value, may not be desirable.  Using a SQL expression means the value
    will be re-fetched from the database within the context of retrieving
    generated defaults.


    """

<<<<<<< HEAD
    def __init__(self, none_as_null=False):
        """Construct a :class:`_types.JSON` type.

        :param none_as_null=False: if True, persist the value ``None`` as a
         SQL NULL value, not the JSON encoding of ``null``.   Note that
         when this flag is False, the :func:`.null` construct can still
         be used to persist a NULL value::

             from sqlalchemy import null
             conn.execute(table.insert(), data=null())
=======
    def __init__(self, none_as_null: bool = False):
        """Construct a :class:`_types.JSON` type.

        :param none_as_null=False: if True, persist the value ``None`` as a
         SQL NULL value, not the JSON encoding of ``null``. Note that when this
         flag is False, the :func:`.null` construct can still be used to
         persist a NULL value, which may be passed directly as a parameter
         value that is specially interpreted by the :class:`_types.JSON` type
         as SQL NULL::

             from sqlalchemy import null
             conn.execute(table.insert(), {"data": null()})
>>>>>>> 516a66495 (Reinitialize repository and add files)

         .. note::

              :paramref:`_types.JSON.none_as_null` does **not** apply to the
              values passed to :paramref:`_schema.Column.default` and
              :paramref:`_schema.Column.server_default`; a value of ``None``
              passed for these parameters means "no default present".

<<<<<<< HEAD
=======
              Additionally, when used in SQL comparison expressions, the
              Python value ``None`` continues to refer to SQL null, and not
              JSON NULL.  The :paramref:`_types.JSON.none_as_null` flag refers
              explicitly to the **persistence** of the value within an
              INSERT or UPDATE statement.   The :attr:`_types.JSON.NULL`
              value should be used for SQL expressions that wish to compare to
              JSON null.

>>>>>>> 516a66495 (Reinitialize repository and add files)
         .. seealso::

              :attr:`.types.JSON.NULL`

        """
        self.none_as_null = none_as_null

<<<<<<< HEAD
    class JSONElementType(TypeEngine):
=======
    class JSONElementType(TypeEngine[Any]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Common function for index / path elements in a JSON expression."""

        _integer = Integer()
        _string = String()

        def string_bind_processor(self, dialect):
            return self._string._cached_bind_processor(dialect)

        def string_literal_processor(self, dialect):
            return self._string._cached_literal_processor(dialect)

        def bind_processor(self, dialect):
            int_processor = self._integer._cached_bind_processor(dialect)
            string_processor = self.string_bind_processor(dialect)

            def process(value):
                if int_processor and isinstance(value, int):
                    value = int_processor(value)
<<<<<<< HEAD
                elif string_processor and isinstance(value, util.string_types):
=======
                elif string_processor and isinstance(value, str):
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    value = string_processor(value)
                return value

            return process

        def literal_processor(self, dialect):
            int_processor = self._integer._cached_literal_processor(dialect)
            string_processor = self.string_literal_processor(dialect)

            def process(value):
                if int_processor and isinstance(value, int):
                    value = int_processor(value)
<<<<<<< HEAD
                elif string_processor and isinstance(value, util.string_types):
                    value = string_processor(value)
=======
                elif string_processor and isinstance(value, str):
                    value = string_processor(value)
                else:
                    raise NotImplementedError()

>>>>>>> 516a66495 (Reinitialize repository and add files)
                return value

            return process

    class JSONIndexType(JSONElementType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """

<<<<<<< HEAD
=======
    class JSONIntIndexType(JSONIndexType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """

    class JSONStrIndexType(JSONIndexType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """

>>>>>>> 516a66495 (Reinitialize repository and add files)
    class JSONPathType(JSONElementType):
        """Placeholder type for JSON path operations.

        This allows execution-time processing of a path-based
        index value into a specific SQL syntax.

        """

<<<<<<< HEAD
    class Comparator(Indexable.Comparator, Concatenable.Comparator):
        """Define comparison operations for :class:`_types.JSON`."""

        @util.dependencies("sqlalchemy.sql.default_comparator")
        def _setup_getitem(self, default_comparator, index):
            if not isinstance(index, util.string_types) and isinstance(
                index, compat.collections_abc.Sequence
            ):
                index = default_comparator._check_literal(
                    self.expr,
                    operators.json_path_getitem_op,
                    index,
=======
        __visit_name__ = "json_path"

    class Comparator(Indexable.Comparator[_T], Concatenable.Comparator[_T]):
        """Define comparison operations for :class:`_types.JSON`."""

        __slots__ = ()

        def _setup_getitem(self, index):
            if not isinstance(index, str) and isinstance(
                index, collections_abc.Sequence
            ):
                index = coercions.expect(
                    roles.BinaryElementRole,
                    index,
                    expr=self.expr,
                    operator=operators.json_path_getitem_op,
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    bindparam_type=JSON.JSONPathType,
                )

                operator = operators.json_path_getitem_op
            else:
<<<<<<< HEAD
                index = default_comparator._check_literal(
                    self.expr,
                    operators.json_getitem_op,
                    index,
                    bindparam_type=JSON.JSONIndexType,
=======
                index = coercions.expect(
                    roles.BinaryElementRole,
                    index,
                    expr=self.expr,
                    operator=operators.json_getitem_op,
                    bindparam_type=(
                        JSON.JSONIntIndexType
                        if isinstance(index, int)
                        else JSON.JSONStrIndexType
                    ),
>>>>>>> 516a66495 (Reinitialize repository and add files)
                )
                operator = operators.json_getitem_op

            return operator, index, self.type

        def as_boolean(self):
            """Cast an indexed value as boolean.

            e.g.::

<<<<<<< HEAD
                stmt = select([
                    mytable.c.json_column['some_data'].as_boolean()
                ]).where(
=======
                stmt = select(
                    mytable.c.json_column['some_data'].as_boolean()
                ).where(
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    mytable.c.json_column['some_data'].as_boolean() == True
                )

            .. versionadded:: 1.3.11

            """
            return self._binary_w_type(Boolean(), "as_boolean")

        def as_string(self):
            """Cast an indexed value as string.

            e.g.::

<<<<<<< HEAD
                stmt = select([
                    mytable.c.json_column['some_data'].as_string()
                ]).where(
=======
                stmt = select(
                    mytable.c.json_column['some_data'].as_string()
                ).where(
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    mytable.c.json_column['some_data'].as_string() ==
                    'some string'
                )

            .. versionadded:: 1.3.11

            """
<<<<<<< HEAD
            return self._binary_w_type(String(), "as_string")
=======
            return self._binary_w_type(Unicode(), "as_string")
>>>>>>> 516a66495 (Reinitialize repository and add files)

        def as_integer(self):
            """Cast an indexed value as integer.

            e.g.::

<<<<<<< HEAD
                stmt = select([
                    mytable.c.json_column['some_data'].as_integer()
                ]).where(
=======
                stmt = select(
                    mytable.c.json_column['some_data'].as_integer()
                ).where(
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    mytable.c.json_column['some_data'].as_integer() == 5
                )

            .. versionadded:: 1.3.11

            """
            return self._binary_w_type(Integer(), "as_integer")

        def as_float(self):
            """Cast an indexed value as float.

            e.g.::

<<<<<<< HEAD
                stmt = select([
                    mytable.c.json_column['some_data'].as_float()
                ]).where(
=======
                stmt = select(
                    mytable.c.json_column['some_data'].as_float()
                ).where(
>>>>>>> 516a66495 (Reinitialize repository and add files)
                    mytable.c.json_column['some_data'].as_float() == 29.75
                )

            .. versionadded:: 1.3.11

            """
<<<<<<< HEAD
            # note there's no Numeric or Decimal support here yet
            return self._binary_w_type(Float(), "as_float")

        def as_json(self):
            """Cast an indexed value as JSON.

            This is the default behavior of indexed elements in any case.
=======
            return self._binary_w_type(Float(), "as_float")

        def as_numeric(self, precision, scale, asdecimal=True):
            """Cast an indexed value as numeric/decimal.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_numeric(10, 6)
                ).where(
                    mytable.c.
                    json_column['some_data'].as_numeric(10, 6) == 29.75
                )

            .. versionadded:: 1.4.0b2

            """
            return self._binary_w_type(
                Numeric(precision, scale, asdecimal=asdecimal), "as_numeric"
            )

        def as_json(self):
            """Cast an indexed value as JSON.

            e.g.::

                stmt = select(mytable.c.json_column['some_data'].as_json())

            This is typically the default behavior of indexed elements in any
            case.
>>>>>>> 516a66495 (Reinitialize repository and add files)

            Note that comparison of full JSON structures may not be
            supported by all backends.

            .. versionadded:: 1.3.11

            """
            return self.expr

        def _binary_w_type(self, typ, method_name):
            if not isinstance(
                self.expr, elements.BinaryExpression
            ) or self.expr.operator not in (
                operators.json_getitem_op,
                operators.json_path_getitem_op,
            ):
                raise exc.InvalidRequestError(
                    "The JSON cast operator JSON.%s() only works with a JSON "
                    "index expression e.g. col['q'].%s()"
                    % (method_name, method_name)
                )
            expr = self.expr._clone()
            expr.type = typ
            return expr

    comparator_factory = Comparator

    @property
    def python_type(self):
        return dict

<<<<<<< HEAD
    @property
=======
    @property  # type: ignore  # mypy property bug
>>>>>>> 516a66495 (Reinitialize repository and add files)
    def should_evaluate_none(self):
        """Alias of :attr:`_types.JSON.none_as_null`"""
        return not self.none_as_null

    @should_evaluate_none.setter
    def should_evaluate_none(self, value):
        self.none_as_null = not value

    @util.memoized_property
    def _str_impl(self):
<<<<<<< HEAD
        return String(_expect_unicode=True)

    def bind_processor(self, dialect):
        string_process = self._str_impl.bind_processor(dialect)

        json_serializer = dialect._json_serializer or json.dumps

        def process(value):
            if value is self.NULL:
                value = None
            elif isinstance(value, elements.Null) or (
                value is None and self.none_as_null
            ):
                return None

            serialized = json_serializer(value)
            if string_process:
                serialized = string_process(serialized)
            return serialized

        return process
=======
        return String()

    def _make_bind_processor(self, string_process, json_serializer):
        if string_process:

            def process(value):
                if value is self.NULL:
                    value = None
                elif isinstance(value, elements.Null) or (
                    value is None and self.none_as_null
                ):
                    return None

                serialized = json_serializer(value)
                return string_process(serialized)

        else:

            def process(value):
                if value is self.NULL:
                    value = None
                elif isinstance(value, elements.Null) or (
                    value is None and self.none_as_null
                ):
                    return None

                return json_serializer(value)

        return process

    def bind_processor(self, dialect):
        string_process = self._str_impl.bind_processor(dialect)
        json_serializer = dialect._json_serializer or json.dumps

        return self._make_bind_processor(string_process, json_serializer)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def result_processor(self, dialect, coltype):
        string_process = self._str_impl.result_processor(dialect, coltype)
        json_deserializer = dialect._json_deserializer or json.loads

        def process(value):
            if value is None:
                return None
            if string_process:
                value = string_process(value)
            return json_deserializer(value)

        return process


<<<<<<< HEAD
class ARRAY(SchemaEventTarget, Indexable, Concatenable, TypeEngine):
    """Represent a SQL Array type.

    .. note::  This type serves as the basis for all ARRAY operations.
       However, currently **only the PostgreSQL backend has support
       for SQL arrays in SQLAlchemy**.  It is recommended to use the
       :class:`_postgresql.ARRAY` type directly when using ARRAY types
       with PostgreSQL, as it provides additional operators specific
       to that backend.
=======
class ARRAY(
    SchemaEventTarget, Indexable, Concatenable, TypeEngine[Sequence[Any]]
):
    """Represent a SQL Array type.

    .. note::  This type serves as the basis for all ARRAY operations.
       However, currently **only the PostgreSQL backend has support for SQL
       arrays in SQLAlchemy**. It is recommended to use the PostgreSQL-specific
       :class:`sqlalchemy.dialects.postgresql.ARRAY` type directly when using
       ARRAY types with PostgreSQL, as it provides additional operators
       specific to that backend.
>>>>>>> 516a66495 (Reinitialize repository and add files)

    :class:`_types.ARRAY` is part of the Core in support of various SQL
    standard functions such as :class:`_functions.array_agg`
    which explicitly involve
    arrays; however, with the exception of the PostgreSQL backend and possibly
    some third-party dialects, no other SQLAlchemy built-in dialect has support
    for this type.

    An :class:`_types.ARRAY` type is constructed given the "type"
    of element::

        mytable = Table("mytable", metadata,
                Column("data", ARRAY(Integer))
            )

    The above type represents an N-dimensional array,
    meaning a supporting backend such as PostgreSQL will interpret values
    with any number of dimensions automatically.   To produce an INSERT
    construct that passes in a 1-dimensional array of integers::

        connection.execute(
                mytable.insert(),
<<<<<<< HEAD
                data=[1,2,3]
=======
                {"data": [1,2,3]}
>>>>>>> 516a66495 (Reinitialize repository and add files)
        )

    The :class:`_types.ARRAY` type can be constructed given a fixed number
    of dimensions::

        mytable = Table("mytable", metadata,
                Column("data", ARRAY(Integer, dimensions=2))
            )

    Sending a number of dimensions is optional, but recommended if the
    datatype is to represent arrays of more than one dimension.  This number
    is used:

    * When emitting the type declaration itself to the database, e.g.
      ``INTEGER[][]``

    * When translating Python values to database values, and vice versa, e.g.
      an ARRAY of :class:`.Unicode` objects uses this number to efficiently
      access the string values inside of array structures without resorting
      to per-row type inspection

    * When used with the Python ``getitem`` accessor, the number of dimensions
      serves to define the kind of type that the ``[]`` operator should
      return, e.g. for an ARRAY of INTEGER with two dimensions::

          >>> expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1)
          >>> expr = expr[6]  # returns Integer

    For 1-dimensional arrays, an :class:`_types.ARRAY` instance with no
    dimension parameter will generally assume single-dimensional behaviors.

    SQL expressions of type :class:`_types.ARRAY` have support for "index" and
<<<<<<< HEAD
    "slice" behavior.  The Python ``[]`` operator works normally here, given
    integer indexes or slices.  Arrays default to 1-based indexing.
    The operator produces binary expression
    constructs which will produce the appropriate SQL, both for
    SELECT statements::

        select([mytable.c.data[5], mytable.c.data[2:7]])

    as well as UPDATE statements when the :meth:`_expression.Update.values`
    method
    is used::
=======
    "slice" behavior.  The ``[]`` operator produces expression
    constructs which will produce the appropriate SQL, both for
    SELECT statements::

        select(mytable.c.data[5], mytable.c.data[2:7])

    as well as UPDATE statements when the :meth:`_expression.Update.values`
    method is used::
>>>>>>> 516a66495 (Reinitialize repository and add files)

        mytable.update().values({
            mytable.c.data[5]: 7,
            mytable.c.data[2:7]: [1, 2, 3]
        })

<<<<<<< HEAD
=======
    Indexed access is one-based by default;
    for zero-based index conversion, set :paramref:`_types.ARRAY.zero_indexes`.

>>>>>>> 516a66495 (Reinitialize repository and add files)
    The :class:`_types.ARRAY` type also provides for the operators
    :meth:`.types.ARRAY.Comparator.any` and
    :meth:`.types.ARRAY.Comparator.all`. The PostgreSQL-specific version of
    :class:`_types.ARRAY` also provides additional operators.

<<<<<<< HEAD
    .. versionadded:: 1.1.0

    .. seealso::

        :class:`_postgresql.ARRAY`
=======
    .. container:: topic

        **Detecting Changes in ARRAY columns when using the ORM**

        The :class:`_sqltypes.ARRAY` type, when used with the SQLAlchemy ORM,
        does not detect in-place mutations to the array. In order to detect
        these, the :mod:`sqlalchemy.ext.mutable` extension must be used, using
        the :class:`.MutableList` class::

            from sqlalchemy import ARRAY
            from sqlalchemy.ext.mutable import MutableList

            class SomeOrmClass(Base):
                # ...

                data = Column(MutableList.as_mutable(ARRAY(Integer)))

        This extension will allow "in-place" changes such to the array
        such as ``.append()`` to produce events which will be detected by the
        unit of work.  Note that changes to elements **inside** the array,
        including subarrays that are mutated in place, are **not** detected.

        Alternatively, assigning a new array value to an ORM element that
        replaces the old one will always trigger a change event.

    .. seealso::

        :class:`sqlalchemy.dialects.postgresql.ARRAY`
>>>>>>> 516a66495 (Reinitialize repository and add files)

    """

    __visit_name__ = "ARRAY"

    _is_array = True

    zero_indexes = False
    """If True, Python zero-based indexes should be interpreted as one-based
    on the SQL expression side."""

<<<<<<< HEAD
    class Comparator(Indexable.Comparator, Concatenable.Comparator):

        """Define comparison operations for :class:`_types.ARRAY`.

        More operators are available on the dialect-specific form
        of this type.  See :class:`.postgresql.ARRAY.Comparator`.

        """

        def _setup_getitem(self, index):
            if isinstance(index, slice):
                return_type = self.type
                if self.type.zero_indexes:
                    index = slice(index.start + 1, index.stop + 1, index.step)
                index = Slice(
                    _literal_as_binds(
                        index.start,
                        name=self.expr.key,
                        type_=type_api.INTEGERTYPE,
                    ),
                    _literal_as_binds(
                        index.stop,
                        name=self.expr.key,
                        type_=type_api.INTEGERTYPE,
                    ),
                    _literal_as_binds(
                        index.step,
                        name=self.expr.key,
                        type_=type_api.INTEGERTYPE,
                    ),
                )
            else:
                if self.type.zero_indexes:
                    index += 1
                if self.type.dimensions is None or self.type.dimensions == 1:
                    return_type = self.type.item_type
                else:
                    adapt_kw = {"dimensions": self.type.dimensions - 1}
                    return_type = self.type.adapt(
                        self.type.__class__, **adapt_kw
                    )

            return operators.getitem, index, return_type

        def contains(self, *arg, **kw):
            raise NotImplementedError(
                "ARRAY.contains() not implemented for the base "
                "ARRAY type; please use the dialect-specific ARRAY type"
            )

        @util.dependencies("sqlalchemy.sql.elements")
        def any(self, elements, other, operator=None):
            """Return ``other operator ANY (array)`` clause.

            Argument places are switched, because ANY requires array
            expression to be on the right hand-side.

            E.g.::

                from sqlalchemy.sql import operators

                conn.execute(
                    select([table.c.data]).where(
                            table.c.data.any(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.any_`

                :meth:`.types.ARRAY.Comparator.all`

            """
            operator = operator if operator else operators.eq

            # send plain BinaryExpression so that negate remains at None,
            # leading to NOT expr for negation.
            return elements.BinaryExpression(
                elements._literal_as_binds(other),
                elements.CollectionAggregate._create_any(self.expr),
                operator,
            )

        @util.dependencies("sqlalchemy.sql.elements")
        def all(self, elements, other, operator=None):
            """Return ``other operator ALL (array)`` clause.

            Argument places are switched, because ALL requires array
            expression to be on the right hand-side.

            E.g.::

                from sqlalchemy.sql import operators

                conn.execute(
                    select([table.c.data]).where(
                            table.c.data.all(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.all_`

                :meth:`.types.ARRAY.Comparator.any`

            """
            operator = operator if operator else operators.eq

            # send plain BinaryExpression so that negate remains at None,
            # leading to NOT expr for negation.
            return elements.BinaryExpression(
                elements._literal_as_binds(other),
                elements.CollectionAggregate._create_all(self.expr),
                operator,
            )

    comparator_factory = Comparator

    def __init__(
        self, item_type, as_tuple=False, dimensions=None, zero_indexes=False
=======
    def __init__(
        self,
        item_type: _TypeEngineArgument[Any],
        as_tuple: bool = False,
        dimensions: Optional[int] = None,
        zero_indexes: bool = False,
>>>>>>> 516a66495 (Reinitialize repository and add files)
    ):
        """Construct an :class:`_types.ARRAY`.

        E.g.::

          Column('myarray', ARRAY(Integer))

        Arguments are:

        :param item_type: The data type of items of this array. Note that
          dimensionality is irrelevant here, so multi-dimensional arrays like
          ``INTEGER[][]``, are constructed as ``ARRAY(Integer)``, not as
          ``ARRAY(ARRAY(Integer))`` or such.

        :param as_tuple=False: Specify whether return results
          should be converted to tuples from lists.  This parameter is
          not generally needed as a Python list corresponds well
          to a SQL array.

        :param dimensions: if non-None, the ARRAY will assume a fixed
         number of dimensions.   This impacts how the array is declared
         on the database, how it goes about interpreting Python and
         result values, as well as how expression behavior in conjunction
         with the "getitem" operator works.  See the description at
         :class:`_types.ARRAY` for additional detail.

        :param zero_indexes=False: when True, index values will be converted
         between Python zero-based and SQL one-based indexes, e.g.
         a value of one will be added to all index values before passing
         to the database.

        """
        if isinstance(item_type, ARRAY):
            raise ValueError(
                "Do not nest ARRAY types; ARRAY(basetype) "
                "handles multi-dimensional arrays of basetype"
            )
        if isinstance(item_type, type):
            item_type = item_type()
        self.item_type = item_type
        self.as_tuple = as_tuple
        self.dimensions = dimensions
        self.zero_indexes = zero_indexes

<<<<<<< HEAD
=======
    class Comparator(
        Indexable.Comparator[Sequence[Any]],
        Concatenable.Comparator[Sequence[Any]],
    ):
        """Define comparison operations for :class:`_types.ARRAY`.

        More operators are available on the dialect-specific form
        of this type.  See :class:`.postgresql.ARRAY.Comparator`.

        """

        __slots__ = ()

        type: ARRAY

        def _setup_getitem(self, index):
            arr_type = self.type

            return_type: TypeEngine[Any]

            if isinstance(index, slice):
                return_type = arr_type
                if arr_type.zero_indexes:
                    index = slice(index.start + 1, index.stop + 1, index.step)
                slice_ = Slice(
                    index.start, index.stop, index.step, _name=self.expr.key
                )
                return operators.getitem, slice_, return_type
            else:
                if arr_type.zero_indexes:
                    index += 1
                if arr_type.dimensions is None or arr_type.dimensions == 1:
                    return_type = arr_type.item_type
                else:
                    adapt_kw = {"dimensions": arr_type.dimensions - 1}
                    return_type = arr_type.adapt(
                        arr_type.__class__, **adapt_kw
                    )

                return operators.getitem, index, return_type

        def contains(self, *arg, **kw):
            """``ARRAY.contains()`` not implemented for the base ARRAY type.
            Use the dialect-specific ARRAY type.

            .. seealso::

                :class:`_postgresql.ARRAY` - PostgreSQL specific version.
            """
            raise NotImplementedError(
                "ARRAY.contains() not implemented for the base "
                "ARRAY type; please use the dialect-specific ARRAY type"
            )

        @util.preload_module("sqlalchemy.sql.elements")
        def any(self, other, operator=None):
            """Return ``other operator ANY (array)`` clause.

            .. legacy:: This method is an :class:`_types.ARRAY` - specific
                construct that is now superseded by the :func:`_sql.any_`
                function, which features a different calling style. The
                :func:`_sql.any_` function is also mirrored at the method level
                via the :meth:`_sql.ColumnOperators.any_` method.

            Usage of array-specific :meth:`_types.ARRAY.Comparator.any`
            is as follows::

                from sqlalchemy.sql import operators

                conn.execute(
                    select(table.c.data).where(
                            table.c.data.any(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.any_`

                :meth:`.types.ARRAY.Comparator.all`

            """
            elements = util.preloaded.sql_elements
            operator = operator if operator else operators.eq

            arr_type = self.type

            return elements.CollectionAggregate._create_any(self.expr).operate(
                operators.mirror(operator),
                coercions.expect(
                    roles.BinaryElementRole,
                    element=other,
                    operator=operator,
                    expr=self.expr,
                    bindparam_type=arr_type.item_type,
                ),
            )

        @util.preload_module("sqlalchemy.sql.elements")
        def all(self, other, operator=None):
            """Return ``other operator ALL (array)`` clause.

            .. legacy:: This method is an :class:`_types.ARRAY` - specific
                construct that is now superseded by the :func:`_sql.all_`
                function, which features a different calling style. The
                :func:`_sql.all_` function is also mirrored at the method level
                via the :meth:`_sql.ColumnOperators.all_` method.

            Usage of array-specific :meth:`_types.ARRAY.Comparator.all`
            is as follows::

                from sqlalchemy.sql import operators

                conn.execute(
                    select(table.c.data).where(
                            table.c.data.all(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.all_`

                :meth:`.types.ARRAY.Comparator.any`

            """
            elements = util.preloaded.sql_elements
            operator = operator if operator else operators.eq

            arr_type = self.type

            return elements.CollectionAggregate._create_all(self.expr).operate(
                operators.mirror(operator),
                coercions.expect(
                    roles.BinaryElementRole,
                    element=other,
                    operator=operator,
                    expr=self.expr,
                    bindparam_type=arr_type.item_type,
                ),
            )

    comparator_factory = Comparator

>>>>>>> 516a66495 (Reinitialize repository and add files)
    @property
    def hashable(self):
        return self.as_tuple

    @property
    def python_type(self):
        return list

    def compare_values(self, x, y):
        return x == y

<<<<<<< HEAD
    def _set_parent(self, column, **kw):
        """Support SchemaEventTarget"""

        if isinstance(self.item_type, SchemaEventTarget):
            self.item_type._set_parent(column, **kw)

    def _set_parent_with_dispatch(self, parent, **kw):
        """Support SchemaEventTarget"""

        super(ARRAY, self)._set_parent_with_dispatch(parent)
=======
    def _set_parent(self, column, outer=False, **kw):
        """Support SchemaEventTarget"""

        if not outer and isinstance(self.item_type, SchemaEventTarget):
            self.item_type._set_parent(column, **kw)

    def _set_parent_with_dispatch(self, parent):
        """Support SchemaEventTarget"""

        super()._set_parent_with_dispatch(parent, outer=True)
>>>>>>> 516a66495 (Reinitialize repository and add files)

        if isinstance(self.item_type, SchemaEventTarget):
            self.item_type._set_parent_with_dispatch(parent)

<<<<<<< HEAD

class REAL(Float):

    """The SQL REAL type."""
=======
    def literal_processor(self, dialect):
        item_proc = self.item_type.dialect_impl(dialect).literal_processor(
            dialect
        )
        if item_proc is None:
            return None

        def to_str(elements):
            return f"[{', '.join(elements)}]"

        def process(value):
            inner = self._apply_item_processor(
                value, item_proc, self.dimensions, to_str
            )
            return inner

        return process

    def _apply_item_processor(self, arr, itemproc, dim, collection_callable):
        """Helper method that can be used by bind_processor(),
        literal_processor(), etc. to apply an item processor to elements of
        an array value, taking into account the 'dimensions' for this
        array type.

        See the Postgresql ARRAY datatype for usage examples.

        .. versionadded:: 2.0

        """

        if dim is None:
            arr = list(arr)
        if (
            dim == 1
            or dim is None
            and (
                # this has to be (list, tuple), or at least
                # not hasattr('__iter__'), since Py3K strings
                # etc. have __iter__
                not arr
                or not isinstance(arr[0], (list, tuple))
            )
        ):
            if itemproc:
                return collection_callable(itemproc(x) for x in arr)
            else:
                return collection_callable(arr)
        else:
            return collection_callable(
                (
                    self._apply_item_processor(
                        x,
                        itemproc,
                        dim - 1 if dim is not None else None,
                        collection_callable,
                    )
                    if x is not None
                    else None
                )
                for x in arr
            )


class TupleType(TypeEngine[Tuple[Any, ...]]):
    """represent the composite type of a Tuple."""

    _is_tuple_type = True

    types: List[TypeEngine[Any]]

    def __init__(self, *types: _TypeEngineArgument[Any]):
        self._fully_typed = NULLTYPE not in types
        self.types = [
            item_type() if isinstance(item_type, type) else item_type
            for item_type in types
        ]

    def coerce_compared_value(
        self, op: Optional[OperatorType], value: Any
    ) -> TypeEngine[Any]:
        if value is type_api._NO_VALUE_IN_LIST:
            return super().coerce_compared_value(op, value)
        else:
            return TupleType(
                *[
                    typ.coerce_compared_value(op, elem)
                    for typ, elem in zip(self.types, value)
                ]
            )

    def _resolve_values_to_types(self, value: Any) -> TupleType:
        if self._fully_typed:
            return self
        else:
            return TupleType(
                *[
                    _resolve_value_to_type(elem) if typ is NULLTYPE else typ
                    for typ, elem in zip(self.types, value)
                ]
            )

    def result_processor(self, dialect, coltype):
        raise NotImplementedError(
            "The tuple type does not support being fetched "
            "as a column in a result row."
        )


class REAL(Float[_N]):
    """The SQL REAL type.

    .. seealso::

        :class:`_types.Float` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "REAL"


<<<<<<< HEAD
class FLOAT(Float):

    """The SQL FLOAT type."""
=======
class FLOAT(Float[_N]):
    """The SQL FLOAT type.

    .. seealso::

        :class:`_types.Float` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "FLOAT"


<<<<<<< HEAD
class NUMERIC(Numeric):

    """The SQL NUMERIC type."""
=======
class DOUBLE(Double[_N]):
    """The SQL DOUBLE type.

    .. versionadded:: 2.0

    .. seealso::

        :class:`_types.Double` - documentation for the base type.

    """

    __visit_name__ = "DOUBLE"


class DOUBLE_PRECISION(Double[_N]):
    """The SQL DOUBLE PRECISION type.

    .. versionadded:: 2.0

    .. seealso::

        :class:`_types.Double` - documentation for the base type.

    """

    __visit_name__ = "DOUBLE_PRECISION"


class NUMERIC(Numeric[_N]):
    """The SQL NUMERIC type.

    .. seealso::

        :class:`_types.Numeric` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "NUMERIC"


<<<<<<< HEAD
class DECIMAL(Numeric):

    """The SQL DECIMAL type."""
=======
class DECIMAL(Numeric[_N]):
    """The SQL DECIMAL type.

    .. seealso::

        :class:`_types.Numeric` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "DECIMAL"


class INTEGER(Integer):
<<<<<<< HEAD

    """The SQL INT or INTEGER type."""
=======
    """The SQL INT or INTEGER type.

    .. seealso::

        :class:`_types.Integer` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "INTEGER"


INT = INTEGER


class SMALLINT(SmallInteger):
<<<<<<< HEAD

    """The SQL SMALLINT type."""
=======
    """The SQL SMALLINT type.

    .. seealso::

        :class:`_types.SmallInteger` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "SMALLINT"


class BIGINT(BigInteger):
<<<<<<< HEAD

    """The SQL BIGINT type."""
=======
    """The SQL BIGINT type.

    .. seealso::

        :class:`_types.BigInteger` - documentation for the base type.

    """
>>>>>>> 516a66495 (Reinitialize repository and add files)

    __visit_name__ = "BIGINT"


class TIMESTAMP(DateTime):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL TIMESTAMP type.

    :class:`_types.TIMESTAMP` datatypes have support for timezone
    storage on some backends, such as PostgreSQL and Oracle.  Use the
    :paramref:`~types.TIMESTAMP.timezone` argument in order to enable
    "TIMESTAMP WITH TIMEZONE" for these backends.

    """

    __visit_name__ = "TIMESTAMP"

<<<<<<< HEAD
    def __init__(self, timezone=False):
=======
    def __init__(self, timezone: bool = False):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Construct a new :class:`_types.TIMESTAMP`.

        :param timezone: boolean.  Indicates that the TIMESTAMP type should
         enable timezone support, if available on the target database.
         On a per-dialect basis is similar to "TIMESTAMP WITH TIMEZONE".
         If the target database does not support timezones, this flag is
         ignored.


        """
<<<<<<< HEAD
        super(TIMESTAMP, self).__init__(timezone=timezone)
=======
        super().__init__(timezone=timezone)
>>>>>>> 516a66495 (Reinitialize repository and add files)

    def get_dbapi_type(self, dbapi):
        return dbapi.TIMESTAMP


class DATETIME(DateTime):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL DATETIME type."""

    __visit_name__ = "DATETIME"


class DATE(Date):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL DATE type."""

    __visit_name__ = "DATE"


class TIME(Time):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL TIME type."""

    __visit_name__ = "TIME"


class TEXT(Text):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL TEXT type."""

    __visit_name__ = "TEXT"


class CLOB(Text):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The CLOB type.

    This type is found in Oracle and Informix.
    """

    __visit_name__ = "CLOB"


class VARCHAR(String):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL VARCHAR type."""

    __visit_name__ = "VARCHAR"


class NVARCHAR(Unicode):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL NVARCHAR type."""

    __visit_name__ = "NVARCHAR"


class CHAR(String):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL CHAR type."""

    __visit_name__ = "CHAR"


class NCHAR(Unicode):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL NCHAR type."""

    __visit_name__ = "NCHAR"


class BLOB(LargeBinary):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL BLOB type."""

    __visit_name__ = "BLOB"


class BINARY(_Binary):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL BINARY type."""

    __visit_name__ = "BINARY"


class VARBINARY(_Binary):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL VARBINARY type."""

    __visit_name__ = "VARBINARY"


class BOOLEAN(Boolean):
<<<<<<< HEAD

=======
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """The SQL BOOLEAN type."""

    __visit_name__ = "BOOLEAN"


<<<<<<< HEAD
class NullType(TypeEngine):

=======
class NullType(TypeEngine[None]):
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """An unknown type.

    :class:`.NullType` is used as a default type for those cases where
    a type cannot be determined, including:

    * During table reflection, when the type of a column is not recognized
      by the :class:`.Dialect`
    * When constructing SQL expressions using plain Python objects of
      unknown types (e.g. ``somecolumn == my_special_object``)
    * When a new :class:`_schema.Column` is created,
      and the given type is passed
      as ``None`` or is not passed at all.

    The :class:`.NullType` can be used within SQL expression invocation
    without issue, it just has no behavior either at the expression
    construction level or at the bind-parameter/result processing level.
    :class:`.NullType` will result in a :exc:`.CompileError` if the compiler
    is asked to render the type itself, such as if it is used in a
    :func:`.cast` operation or within a schema creation operation such as that
    invoked by :meth:`_schema.MetaData.create_all` or the
    :class:`.CreateTable`
    construct.

    """

    __visit_name__ = "null"

    _isnull = True

<<<<<<< HEAD
    hashable = False

    def literal_processor(self, dialect):
        def process(value):
            return "NULL"

        return process

    class Comparator(TypeEngine.Comparator):
        def _adapt_expression(self, op, other_comparator):
=======
    def literal_processor(self, dialect):
        return None

    class Comparator(TypeEngine.Comparator[_T]):
        __slots__ = ()

        def _adapt_expression(
            self,
            op: OperatorType,
            other_comparator: TypeEngine.Comparator[Any],
        ) -> Tuple[OperatorType, TypeEngine[Any]]:
>>>>>>> 516a66495 (Reinitialize repository and add files)
            if isinstance(
                other_comparator, NullType.Comparator
            ) or not operators.is_commutative(op):
                return op, self.expr.type
            else:
                return other_comparator._adapt_expression(op, self)

    comparator_factory = Comparator


<<<<<<< HEAD
=======
class TableValueType(HasCacheKey, TypeEngine[Any]):
    """Refers to a table value type."""

    _is_table_value = True

    _traverse_internals = [
        ("_elements", InternalTraversal.dp_clauseelement_list),
    ]

    def __init__(self, *elements: Union[str, _ColumnExpressionArgument[Any]]):
        self._elements = [
            coercions.expect(roles.StrAsPlainColumnRole, elem)
            for elem in elements
        ]


>>>>>>> 516a66495 (Reinitialize repository and add files)
class MatchType(Boolean):
    """Refers to the return type of the MATCH operator.

    As the :meth:`.ColumnOperators.match` is probably the most open-ended
    operator in generic SQLAlchemy Core, we can't assume the return type
    at SQL evaluation time, as MySQL returns a floating point, not a boolean,
    and other backends might do something different.    So this type
    acts as a placeholder, currently subclassing :class:`.Boolean`.
    The type allows dialects to inject result-processing functionality
    if needed, and on MySQL will return floating-point values.

<<<<<<< HEAD
    .. versionadded:: 1.0.0

    """

=======
    """


_UUID_RETURN = TypeVar("_UUID_RETURN", str, _python_UUID)


class Uuid(Emulated, TypeEngine[_UUID_RETURN]):
    """Represent a database agnostic UUID datatype.

    For backends that have no "native" UUID datatype, the value will
    make use of ``CHAR(32)`` and store the UUID as a 32-character alphanumeric
    hex string.

    For backends which are known to support ``UUID`` directly or a similar
    uuid-storing datatype such as SQL Server's ``UNIQUEIDENTIFIER``, a
    "native" mode enabled by default allows these types will be used on those
    backends.

    In its default mode of use, the :class:`_sqltypes.Uuid` datatype expects
    **Python uuid objects**, from the Python
    `uuid <https://docs.python.org/3/library/uuid.html>`_
    module::

        import uuid

        from sqlalchemy import Uuid
        from sqlalchemy import Table, Column, MetaData, String


        metadata_obj = MetaData()

        t = Table(
            "t",
            metadata_obj,
            Column('uuid_data', Uuid, primary_key=True),
            Column("other_data", String)
        )

        with engine.begin() as conn:
            conn.execute(
                t.insert(),
                {"uuid_data": uuid.uuid4(), "other_data", "some data"}
            )

    To have the :class:`_sqltypes.Uuid` datatype work with string-based
    Uuids (e.g. 32 character hexadecimal strings), pass the
    :paramref:`_sqltypes.Uuid.as_uuid` parameter with the value ``False``.

    .. versionadded:: 2.0

    .. seealso::

        :class:`_sqltypes.UUID` - represents exactly the ``UUID`` datatype
        without any backend-agnostic behaviors.

    """

    __visit_name__ = "uuid"

    collation: Optional[str] = None

    @overload
    def __init__(
        self: Uuid[_python_UUID],
        as_uuid: Literal[True] = ...,
        native_uuid: bool = ...,
    ): ...

    @overload
    def __init__(
        self: Uuid[str],
        as_uuid: Literal[False] = ...,
        native_uuid: bool = ...,
    ): ...

    def __init__(self, as_uuid: bool = True, native_uuid: bool = True):
        """Construct a :class:`_sqltypes.Uuid` type.

        :param as_uuid=True: if True, values will be interpreted
         as Python uuid objects, converting to/from string via the
         DBAPI.

         .. versionchanged: 2.0 ``as_uuid`` now defaults to ``True``.

        :param native_uuid=True: if True, backends that support either the
         ``UUID`` datatype directly, or a UUID-storing value
         (such as SQL Server's ``UNIQUEIDENTIFIER`` will be used by those
         backends.   If False, a ``CHAR(32)`` datatype will be used for
         all backends regardless of native support.

        """
        self.as_uuid = as_uuid
        self.native_uuid = native_uuid

    @property
    def python_type(self):
        return _python_UUID if self.as_uuid else str

    @property
    def native(self):
        return self.native_uuid

    def coerce_compared_value(self, op, value):
        """See :meth:`.TypeEngine.coerce_compared_value` for a description."""

        if isinstance(value, str):
            return self
        else:
            return super().coerce_compared_value(op, value)

    def bind_processor(self, dialect):
        character_based_uuid = (
            not dialect.supports_native_uuid or not self.native_uuid
        )

        if character_based_uuid:
            if self.as_uuid:

                def process(value):
                    if value is not None:
                        value = value.hex
                    return value

                return process
            else:

                def process(value):
                    if value is not None:
                        value = value.replace("-", "")
                    return value

                return process
        else:
            return None

    def result_processor(self, dialect, coltype):
        character_based_uuid = (
            not dialect.supports_native_uuid or not self.native_uuid
        )

        if character_based_uuid:
            if self.as_uuid:

                def process(value):
                    if value is not None:
                        value = _python_UUID(value)
                    return value

                return process
            else:

                def process(value):
                    if value is not None:
                        value = str(_python_UUID(value))
                    return value

                return process
        else:
            if not self.as_uuid:

                def process(value):
                    if value is not None:
                        value = str(value)
                    return value

                return process
            else:
                return None

    def literal_processor(self, dialect):
        character_based_uuid = (
            not dialect.supports_native_uuid or not self.native_uuid
        )

        if not self.as_uuid:

            def process(value):
                return f"""'{value.replace("-", "").replace("'", "''")}'"""

            return process
        else:
            if character_based_uuid:

                def process(value):
                    return f"""'{value.hex}'"""

                return process
            else:

                def process(value):
                    return f"""'{str(value).replace("'", "''")}'"""

                return process


class UUID(Uuid[_UUID_RETURN], type_api.NativeForEmulated):
    """Represent the SQL UUID type.

    This is the SQL-native form of the :class:`_types.Uuid` database agnostic
    datatype, and is backwards compatible with the previous PostgreSQL-only
    version of ``UUID``.

    The :class:`_sqltypes.UUID` datatype only works on databases that have a
    SQL datatype named ``UUID``. It will not function for backends which don't
    have this exact-named type, including SQL Server. For backend-agnostic UUID
    values with native support, including for SQL Server's ``UNIQUEIDENTIFIER``
    datatype, use the :class:`_sqltypes.Uuid` datatype.

    .. versionadded:: 2.0

    .. seealso::

        :class:`_sqltypes.Uuid`

    """

    __visit_name__ = "UUID"

    @overload
    def __init__(self: UUID[_python_UUID], as_uuid: Literal[True] = ...): ...

    @overload
    def __init__(self: UUID[str], as_uuid: Literal[False] = ...): ...

    def __init__(self, as_uuid: bool = True):
        """Construct a :class:`_sqltypes.UUID` type.


        :param as_uuid=True: if True, values will be interpreted
         as Python uuid objects, converting to/from string via the
         DBAPI.

         .. versionchanged: 2.0 ``as_uuid`` now defaults to ``True``.

        """
        self.as_uuid = as_uuid
        self.native_uuid = True

    @classmethod
    def adapt_emulated_to_native(cls, impl, **kw):
        kw.setdefault("as_uuid", impl.as_uuid)
        return cls(**kw)

>>>>>>> 516a66495 (Reinitialize repository and add files)

NULLTYPE = NullType()
BOOLEANTYPE = Boolean()
STRINGTYPE = String()
INTEGERTYPE = Integer()
<<<<<<< HEAD
MATCHTYPE = MatchType()

_type_map = {
    int: Integer(),
    float: Float(),
    bool: BOOLEANTYPE,
    decimal.Decimal: Numeric(),
    dt.date: Date(),
    dt.datetime: DateTime(),
    dt.time: Time(),
    dt.timedelta: Interval(),
    util.NoneType: NULLTYPE,
}

if util.py3k:
    _type_map[bytes] = LargeBinary()  # noqa
    _type_map[str] = Unicode()
else:
    _type_map[unicode] = Unicode()  # noqa
    _type_map[str] = String()
=======
NUMERICTYPE: Numeric[decimal.Decimal] = Numeric()
MATCHTYPE = MatchType()
TABLEVALUE = TableValueType()
DATETIME_TIMEZONE = DateTime(timezone=True)
TIME_TIMEZONE = Time(timezone=True)
_BIGINTEGER = BigInteger()
_DATETIME = DateTime()
_TIME = Time()
_STRING = String()
_UNICODE = Unicode()

_type_map: Dict[Type[Any], TypeEngine[Any]] = {
    int: Integer(),
    float: Float(),
    bool: BOOLEANTYPE,
    _python_UUID: Uuid(),
    decimal.Decimal: Numeric(),
    dt.date: Date(),
    dt.datetime: _DATETIME,
    dt.time: _TIME,
    dt.timedelta: Interval(),
    type(None): NULLTYPE,
    bytes: LargeBinary(),
    str: _STRING,
    enum.Enum: Enum(enum.Enum),
    Literal: Enum(enum.Enum),  # type: ignore[dict-item]
}

>>>>>>> 516a66495 (Reinitialize repository and add files)

_type_map_get = _type_map.get


<<<<<<< HEAD
def _resolve_value_to_type(value):
    _result_type = _type_map_get(type(value), False)
=======
def _resolve_value_to_type(value: Any) -> TypeEngine[Any]:
    _result_type = _type_map_get(type(value), False)

    if _result_type is False:
        _result_type = getattr(value, "__sa_type_engine__", False)

>>>>>>> 516a66495 (Reinitialize repository and add files)
    if _result_type is False:
        # use inspect() to detect SQLAlchemy built-in
        # objects.
        insp = inspection.inspect(value, False)
        if (
            insp is not None
            and
            # foil mock.Mock() and other impostors by ensuring
            # the inspection target itself self-inspects
            insp.__class__ in inspection._registrars
        ):
            raise exc.ArgumentError(
<<<<<<< HEAD
                "Object %r is not legal as a SQL literal value" % value
            )
        return NULLTYPE
    else:
        return _result_type
=======
                "Object %r is not legal as a SQL literal value" % (value,)
            )
        return NULLTYPE
    else:
        return _result_type._resolve_for_literal(  # type: ignore [union-attr]
            value
        )
>>>>>>> 516a66495 (Reinitialize repository and add files)


# back-assign to type_api
type_api.BOOLEANTYPE = BOOLEANTYPE
type_api.STRINGTYPE = STRINGTYPE
type_api.INTEGERTYPE = INTEGERTYPE
type_api.NULLTYPE = NULLTYPE
<<<<<<< HEAD
type_api.MATCHTYPE = MATCHTYPE
type_api.INDEXABLE = Indexable
type_api._resolve_value_to_type = _resolve_value_to_type
TypeEngine.Comparator.BOOLEANTYPE = BOOLEANTYPE
=======
type_api.NUMERICTYPE = NUMERICTYPE
type_api.MATCHTYPE = MATCHTYPE
type_api.INDEXABLE = INDEXABLE = Indexable
type_api.TABLEVALUE = TABLEVALUE
type_api._resolve_value_to_type = _resolve_value_to_type
>>>>>>> 516a66495 (Reinitialize repository and add files)
