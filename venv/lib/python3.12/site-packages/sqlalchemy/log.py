<<<<<<< HEAD
# sqlalchemy/log.py
# Copyright (C) 2006-2021 the SQLAlchemy authors and contributors
=======
# log.py
# Copyright (C) 2006-2024 the SQLAlchemy authors and contributors
>>>>>>> 516a66495 (Reinitialize repository and add files)
# <see AUTHORS file>
# Includes alterations by Vinay Sajip vinay_sajip@yahoo.co.uk
#
# This module is part of SQLAlchemy and is released under
<<<<<<< HEAD
# the MIT License: http://www.opensource.org/licenses/mit-license.php
=======
# the MIT License: https://www.opensource.org/licenses/mit-license.php
>>>>>>> 516a66495 (Reinitialize repository and add files)

"""Logging control and utilities.

Control of logging for SA can be performed from the regular python logging
module.  The regular dotted module namespace is used, starting at
'sqlalchemy'.  For class-level logging, the class name is appended.

The "echo" keyword parameter, available on SQLA :class:`_engine.Engine`
and :class:`_pool.Pool` objects, corresponds to a logger specific to that
instance only.

"""
<<<<<<< HEAD

import logging
import sys

=======
from __future__ import annotations

import logging
import sys
from typing import Any
from typing import Optional
from typing import overload
from typing import Set
from typing import Type
from typing import TypeVar
from typing import Union

from .util import py311
from .util import py38
from .util.typing import Literal


if py38:
    STACKLEVEL = True
    # needed as of py3.11.0b1
    # #8019
    STACKLEVEL_OFFSET = 2 if py311 else 1
else:
    STACKLEVEL = False
    STACKLEVEL_OFFSET = 0

_IT = TypeVar("_IT", bound="Identified")

_EchoFlagType = Union[None, bool, Literal["debug"]]
>>>>>>> 516a66495 (Reinitialize repository and add files)

# set initial level to WARN.  This so that
# log statements don't occur in the absence of explicit
# logging being enabled for 'sqlalchemy'.
rootlogger = logging.getLogger("sqlalchemy")
if rootlogger.level == logging.NOTSET:
    rootlogger.setLevel(logging.WARN)


<<<<<<< HEAD
def _add_default_handler(logger):
=======
def _add_default_handler(logger: logging.Logger) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(
        logging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s")
    )
    logger.addHandler(handler)


<<<<<<< HEAD
_logged_classes = set()


def class_logger(cls):
    logger = logging.getLogger(cls.__module__ + "." + cls.__name__)
    cls._should_log_debug = lambda self: logger.isEnabledFor(logging.DEBUG)
    cls._should_log_info = lambda self: logger.isEnabledFor(logging.INFO)
=======
_logged_classes: Set[Type[Identified]] = set()


def _qual_logger_name_for_cls(cls: Type[Identified]) -> str:
    return (
        getattr(cls, "_sqla_logger_namespace", None)
        or cls.__module__ + "." + cls.__name__
    )


def class_logger(cls: Type[_IT]) -> Type[_IT]:
    logger = logging.getLogger(_qual_logger_name_for_cls(cls))
    cls._should_log_debug = lambda self: logger.isEnabledFor(  # type: ignore[method-assign]  # noqa: E501
        logging.DEBUG
    )
    cls._should_log_info = lambda self: logger.isEnabledFor(  # type: ignore[method-assign]  # noqa: E501
        logging.INFO
    )
>>>>>>> 516a66495 (Reinitialize repository and add files)
    cls.logger = logger
    _logged_classes.add(cls)
    return cls


<<<<<<< HEAD
class Identified(object):
    logging_name = None

    def _should_log_debug(self):
        return self.logger.isEnabledFor(logging.DEBUG)

    def _should_log_info(self):
        return self.logger.isEnabledFor(logging.INFO)


class InstanceLogger(object):
=======
_IdentifiedLoggerType = Union[logging.Logger, "InstanceLogger"]


class Identified:
    __slots__ = ()

    logging_name: Optional[str] = None

    logger: _IdentifiedLoggerType

    _echo: _EchoFlagType

    def _should_log_debug(self) -> bool:
        return self.logger.isEnabledFor(logging.DEBUG)

    def _should_log_info(self) -> bool:
        return self.logger.isEnabledFor(logging.INFO)


class InstanceLogger:
>>>>>>> 516a66495 (Reinitialize repository and add files)
    """A logger adapter (wrapper) for :class:`.Identified` subclasses.

    This allows multiple instances (e.g. Engine or Pool instances)
    to share a logger, but have its verbosity controlled on a
    per-instance basis.

    The basic functionality is to return a logging level
    which is based on an instance's echo setting.

    Default implementation is:

    'debug' -> logging.DEBUG
    True    -> logging.INFO
    False   -> Effective level of underlying logger (
    logging.WARNING by default)
    None    -> same as False
    """

    # Map echo settings to logger levels
    _echo_map = {
        None: logging.NOTSET,
        False: logging.NOTSET,
        True: logging.INFO,
        "debug": logging.DEBUG,
    }

<<<<<<< HEAD
    def __init__(self, echo, name):
=======
    _echo: _EchoFlagType

    __slots__ = ("echo", "logger")

    def __init__(self, echo: _EchoFlagType, name: str):
>>>>>>> 516a66495 (Reinitialize repository and add files)
        self.echo = echo
        self.logger = logging.getLogger(name)

        # if echo flag is enabled and no handlers,
        # add a handler to the list
        if self._echo_map[echo] <= logging.INFO and not self.logger.handlers:
            _add_default_handler(self.logger)

    #
    # Boilerplate convenience methods
    #
<<<<<<< HEAD
    def debug(self, msg, *args, **kwargs):
=======
    def debug(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate a debug call to the underlying logger."""

        self.log(logging.DEBUG, msg, *args, **kwargs)

<<<<<<< HEAD
    def info(self, msg, *args, **kwargs):
=======
    def info(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate an info call to the underlying logger."""

        self.log(logging.INFO, msg, *args, **kwargs)

<<<<<<< HEAD
    def warning(self, msg, *args, **kwargs):
=======
    def warning(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate a warning call to the underlying logger."""

        self.log(logging.WARNING, msg, *args, **kwargs)

    warn = warning

<<<<<<< HEAD
    def error(self, msg, *args, **kwargs):
=======
    def error(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """
        Delegate an error call to the underlying logger.
        """
        self.log(logging.ERROR, msg, *args, **kwargs)

<<<<<<< HEAD
    def exception(self, msg, *args, **kwargs):
=======
    def exception(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate an exception call to the underlying logger."""

        kwargs["exc_info"] = 1
        self.log(logging.ERROR, msg, *args, **kwargs)

<<<<<<< HEAD
    def critical(self, msg, *args, **kwargs):
=======
    def critical(self, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate a critical call to the underlying logger."""

        self.log(logging.CRITICAL, msg, *args, **kwargs)

<<<<<<< HEAD
    def log(self, level, msg, *args, **kwargs):
=======
    def log(self, level: int, msg: str, *args: Any, **kwargs: Any) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Delegate a log call to the underlying logger.

        The level here is determined by the echo
        flag as well as that of the underlying logger, and
        logger._log() is called directly.

        """

        # inline the logic from isEnabledFor(),
        # getEffectiveLevel(), to avoid overhead.

        if self.logger.manager.disable >= level:
            return

        selected_level = self._echo_map[self.echo]
        if selected_level == logging.NOTSET:
            selected_level = self.logger.getEffectiveLevel()

        if level >= selected_level:
<<<<<<< HEAD
            self.logger._log(level, msg, args, **kwargs)

    def isEnabledFor(self, level):
=======
            if STACKLEVEL:
                kwargs["stacklevel"] = (
                    kwargs.get("stacklevel", 1) + STACKLEVEL_OFFSET
                )

            self.logger._log(level, msg, args, **kwargs)

    def isEnabledFor(self, level: int) -> bool:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """Is this logger enabled for level 'level'?"""

        if self.logger.manager.disable >= level:
            return False
        return level >= self.getEffectiveLevel()

<<<<<<< HEAD
    def getEffectiveLevel(self):
=======
    def getEffectiveLevel(self) -> int:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        """What's the effective level for this logger?"""

        level = self._echo_map[self.echo]
        if level == logging.NOTSET:
            level = self.logger.getEffectiveLevel()
        return level


<<<<<<< HEAD
def instance_logger(instance, echoflag=None):
    """create a logger for an instance that implements :class:`.Identified`."""

    if instance.logging_name:
        name = "%s.%s.%s" % (
            instance.__class__.__module__,
            instance.__class__.__name__,
            instance.logging_name,
        )
    else:
        name = "%s.%s" % (
            instance.__class__.__module__,
            instance.__class__.__name__,
        )

    instance._echo = echoflag
=======
def instance_logger(
    instance: Identified, echoflag: _EchoFlagType = None
) -> None:
    """create a logger for an instance that implements :class:`.Identified`."""

    if instance.logging_name:
        name = "%s.%s" % (
            _qual_logger_name_for_cls(instance.__class__),
            instance.logging_name,
        )
    else:
        name = _qual_logger_name_for_cls(instance.__class__)

    instance._echo = echoflag  # type: ignore

    logger: Union[logging.Logger, InstanceLogger]
>>>>>>> 516a66495 (Reinitialize repository and add files)

    if echoflag in (False, None):
        # if no echo setting or False, return a Logger directly,
        # avoiding overhead of filtering
        logger = logging.getLogger(name)
    else:
        # if a specified echo flag, return an EchoLogger,
        # which checks the flag, overrides normal log
        # levels by calling logger._log()
        logger = InstanceLogger(echoflag, name)

<<<<<<< HEAD
    instance.logger = logger


class echo_property(object):
=======
    instance.logger = logger  # type: ignore


class echo_property:
>>>>>>> 516a66495 (Reinitialize repository and add files)
    __doc__ = """\
    When ``True``, enable log output for this element.

    This has the effect of setting the Python logging level for the namespace
    of this element's class and object reference.  A value of boolean ``True``
    indicates that the loglevel ``logging.INFO`` will be set for the logger,
    whereas the string value ``debug`` will set the loglevel to
    ``logging.DEBUG``.
    """

<<<<<<< HEAD
    def __get__(self, instance, owner):
=======
    @overload
    def __get__(
        self, instance: Literal[None], owner: Type[Identified]
    ) -> echo_property: ...

    @overload
    def __get__(
        self, instance: Identified, owner: Type[Identified]
    ) -> _EchoFlagType: ...

    def __get__(
        self, instance: Optional[Identified], owner: Type[Identified]
    ) -> Union[echo_property, _EchoFlagType]:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        if instance is None:
            return self
        else:
            return instance._echo

<<<<<<< HEAD
    def __set__(self, instance, value):
=======
    def __set__(self, instance: Identified, value: _EchoFlagType) -> None:
>>>>>>> 516a66495 (Reinitialize repository and add files)
        instance_logger(instance, echoflag=value)
